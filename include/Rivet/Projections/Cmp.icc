// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Cmp class.
//

namespace Rivet {

#include <typeinfo>

template <typename T>
inline Cmp<T>::Cmp(const T & t1, const T & t2)
  : value(undefined), objects(&t1, &t2) {}

template <typename T>
template <typename U>
inline Cmp<T>::Cmp(const Cmp<U> & x)
  : value(x.operator int()), objects(0, 0) {}

template <typename T>
template <typename U>
inline const Cmp<T> & Cmp<T>::operator=(const Cmp<U> & x) {
  value = x.operator int();
  return *this;
}

template <typename T>
template <typename U>
inline const Cmp<T> & Cmp<T>::operator||(const Cmp<U> & x) const {
  compare();
  if ( value == equivalent ) value = x.operator int();
  return *this;
}

template <typename T>
inline Cmp<T>::operator int() const {
  compare();
  return value;
}

template <typename T>
inline void Cmp<T>::compare() const {
  if ( value == undefined ) {
    less<T> l;
    if ( l(*objects.first, *objects.second) ) value = ordered;
    else if ( l(*objects.second, *objects.first) ) value = unordered;
    else value = equivalent;
  }
}

inline Cmp<Projection>::Cmp(const Projection & p1, const Projection & p2)
  : value(undefined), objects(&p1, &p2) {}

template <typename U>
inline Cmp<Projection>::Cmp(const Cmp<U> & x)
  : value(x.operator int()), objects(0, 0) {}

template <typename U>
inline const Cmp<Projection> & Cmp<Projection>::operator=(const Cmp<U> & x) {
  value = x.operator int();
  return *this;
}

template <typename U>
inline const Cmp<Projection> &
Cmp<Projection>::operator||(const Cmp<U> & x) const {
  compare();
  if ( value == equivalent ) value = x.operator int();
  return *this;
}

inline Cmp<Projection>::operator int() const {
  compare();
  return value;
}

inline void Cmp<Projection>::compare() const {
  if ( value == undefined ) {
    const std::type_info & id1 = typeid(*objects.first);
    const std::type_info & id2 = typeid(*objects.second);
    if ( id1.before(id2) ) value = ordered;
    else if ( id2.before(id1) ) value = unordered;
    else {
      int c = objects.first->compare(*objects.second);
      if ( c < 0 ) value = ordered;
      else if ( c > 0 ) value = unordered;
      else value = equivalent;
    }
  }
}

}
