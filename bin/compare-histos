#! /usr/bin/env python


## Make "set" a builtin type on Python < 2.4
if not 'set' in dir(__builtins__):
    from sets import Set as set

## Make "sorted" a builtin function on Python < 2.4
if not 'sorted' in dir(__builtins__):
    def sorted(iterable, cmp=None, key=None, reverse=None):
        rtn = iterable
        rtn.sort(cmp)#, key, reverse)
        return rtn


def sanitiseString(s):
    #s = s.replace('_','\\_')
    #s = s.replace('^','\\^{}')
    #s = s.replace('$','\\$')
    s = s.replace('#','\\#')
    s = s.replace('%','\\%')
    return s


##############################################################
## HISTO HACKS UNTIL YODA ARRIVES...
#from professor.rivetreader import *


class Histo:
    def __init__(self):
        self._bins = []
        self.path = None
        self.name = None
        self.title = None
        self.xlabel = ''
        self.ylabel = ''
        self.isdata = False
        #self.isref = False

    def __cmp__(self, other):
        """Sort by $path/$name string"""
        return self.fullPath() > other.fullPath()

    def __str__(self):
        out = "Histogram '%s' with %d bins\n" % (self.fullPath(), self.numBins())
        out += "Title: %s\n" % self.title
        out += "XLabel: %s\n" % self.xlabel
        out += "YLabel: %s\n" % self.ylabel
        out += "\n".join([str(b) for b in self.getBins()])
        return out

    def fullPath(self):
        return os.path.join(self.path, self.name)

    def asFlat(self):
        global headerprefix
        global opts
        out = "# BEGIN HISTOGRAM %s\n" % self.fullPath()
        out += headerprefix + "AidaPath=%s\n" % self.fullPath()
        out += headerprefix + "Title=%s\n" % self.title
        out += headerprefix + "XLabel=%s\n" % self.xlabel
        out += headerprefix + "YLabel=%s\n" % self.ylabel
        out += "## Area: %s\n" % self.area()
        out += "## Num bins: %d\n" % self.numBins()
        if opts.GNUPLOT:
            out += "## xval  \tyval    \txlow    \txhigh    \tylow     \tyhigh\n"
        else:
            out += "## xlow  \txhigh   \tyval    \tyerrminus\tyerrplus\n"
        out += "\n".join([b.asFlat() for b in self.getBins()])
        out += "\n# END HISTOGRAM"
        return out

    def numBins(self):
        return len(self._bins)

    def getBins(self):
        return sorted(self._bins)

    def setBins(self, bins):
        self._bins = bins
        return self

    def addBin(self, bin):
        self._bins.append(bin)
        return self

    def getBin(self, index):
        self._bins.sort()
        return self.getBins()[index]

    bins = property(getBins, setBins)

    def area(self):
        return sum([bin.area() for bin in self.bins])

    def __iter__(self):
        return iter(self.getBins())

    def __len__(self):
        return len(self._bins)

    def __getitem__(self, index):
        return self.getBin(index)


class Bin:
    """A simple container for a binned value with an error."""
    def __init__(self, xlow=None, xhigh=None, yval=0, yerrplus=0, yerrminus=0, focus=None):
        self.xlow = xlow
        self.xhigh= xhigh
        self.yval = yval
        self.yerrplus = yerrplus
        self.yerrminus = yerrminus
        self.focus= focus

    def __str__(self):
        out = "%e to %e: %e +- %e" % (self._xlow, self._xhigh, self._yval, self._yerr)
        return out

    def asFlat(self):
        global opts
        if opts.GNUPLOT:
            out = "%e\t%e\t%e\t%e\t%e\t%e" % (self.getBinCenter(), self.yval,
                                              self.xlow, self.xhigh, 
                                              self.yval-self.yerrminus, self.yval+self.yerrplus)
        else:
            out = "%e\t%e\t%e\t%e\t%e" % (self.xlow, self.xhigh, self.yval, self.yerrminus, self.yerrplus)
        return out

    def __cmp__(self, other):
        """Sort by mean x value (yeah, I know...)"""
        return (self.xlow + self.xhigh) > (other.xlow + other.xhigh)

    def getXRange(self):
        return (self.xlow, self.xhigh)

    def setXRange(self, xlow, xhigh):
        self.xlow = xlow
        self.xhigh = xhigh
        return self

    def getBinCenter(self):
        """Geometric middle of the bin range."""
        return self.xlow + .5*(self.xhigh - self.xlow)

    def getFocus(self):
        """Mean x-value of the bin."""
        if self.focus is not None:
            return (self.xlow + self.xhigh)/2.0
        else:
            return self.focus

    def area(self):
        return self.yval * (self.xhigh - self.xlow)

    def getYErr(self):
        """Get mean of +ve and -ve y-errors."""
        return (self.yerrplus + self.yerrminus)/2.0

    def setYErr(self, yerr):
        """Set both +ve and -ve y-errors simultaneously."""
        self.yerrplus = yerr
        self.yerrminus = yerr
        return self

    yerr = property(getYErr, setYErr)


## Try to load faster but non-standard cElementTree module
try:
    import xml.etree.cElementTree as ET
except ImportError:
    try:
        import cElementTree as ET
    except ImportError:
        try:
            import xml.etree.ElementTree as ET
        except:
            sys.stderr.write("Can't load the ElementTree XML parser: please install it!\n")
            sys.exit(1)


def mkHistoFromDPS(dps):
    """Make a mini histo representation from an AIDA dataPointSet tag."""
    myhist = Histo()
    myhist.name = dps.get("name")
    myhist.title = dps.get("title")
    myhist.path = dps.get("path")
    axes = dps.findall("dimension")
    if (len(axes)==2):
        for a in axes:
            if (a.get("dim")=="0"):
                myhist.xlabel = a.get("title")
            elif (a.get("dim")=="1"):
                myhist.ylabel = a.get("title")
    points = dps.findall("dataPoint")
    numbins = len(points)
    for binnum, point in enumerate(points):
        bin = Bin()
        for d, m in enumerate(point.findall("measurement")):
            val  = float(m.get("value"))
            down = float(m.get("errorMinus"))
            up = float(m.get("errorPlus"))
            if d == 0:
                low  = val - down
                high = val + up
                bin.setXRange(low, high)
            elif d == 1:
                bin.yval = val
                bin.yerrplus = up
                bin.yerrminus = down
        myhist.addBin(bin)
    return myhist


## END HISTO HACKS
##############################################################


if __name__ == "__main__":
    import os, sys, re, logging

    usage = """%prog - generate comparison plots

    USAGE: 
      %prog [options] [REF:'Expt data'] aidafile1:'label 1' [path/to/aidafile2:label2 ...]

    TODO:
      * regex selector
      * ask/force overwrite modes
    """

    ## Try to use Psyco optimiser
    try:
        import psyco
        psyco.full()
    except ImportError:
        pass


    ## Parse command line options
    from optparse import OptionParser
    parser = OptionParser(usage=usage)
    parser.add_option("-o", "--outdir", dest="OUTDIR",
                      default=".", help="write data files into this directory")
    parser.add_option("-l", "--histogram-list", dest="HISTOGRAMLIST",
                      default=None, help="this file contains a list of histograms to plot in the format /ANALYSIS_ID/histogramname, e.g. '/DELPHI_1996_S3430090/d01-x01-y01', on each line.")
    parser.add_option("--hier-out", action="store_true", dest="HIER_OUTPUT", default=False, 
                      help="write output dat files into a directory hierarchy which matches the analysis paths")
    parser.add_option("--linear", action="store_true", dest="LINEAR",
                      default=False, help="plot with linear scale")
    parser.add_option("--logarithmic", action="store_false", dest="LINEAR",
                      default=False, help="plot with logarithmic scale (default behaviour)")
    parser.add_option("--mc-errs", action="store_true", dest="MC_ERRS",
                      default=False, help="show vertical error bars on the MC lines")
    parser.add_option("--no-ratio", action="store_true", dest="NORATIO",
                      default=False, help="disable the ratio plot")
    parser.add_option("--no-ref-only", action="store_true", dest="NO_REF_ONLY",
                      default=True, help="don't make plot file if there is only one dataset to be plotted")
    parser.add_option("--show-ref-only", action="store_false", dest="NO_REF_ONLY",
                      default=True, help="make plot file even if there is only one dataset to be plotted")
    parser.add_option("--refid", dest="REF_ID",
                      default="REF", help="ID of reference data set (file path for non-REF data)")
    parser.add_option("-Q", "--quiet", help="Suppress normal messages", dest="LOGLEVEL",
                      action="store_const", default=logging.INFO, const=logging.WARNING)
    parser.add_option("-V", "--verbose", help="Add extra debug messages", dest="LOGLEVEL",
                      action="store_const", default=logging.INFO, const=logging.DEBUG)
    opts, args = parser.parse_args()

    ## Configure logging
    try:
        logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")
    except:
        logging.getLogger().setLevel(opts.LOGLEVEL)


    ## Line styles
    COLORS = ('red', 'blue', 'blue!8!red!8!green', 'orange', 'magenta')
    LINESTYLES = ('solid', 'dashed', 'dotted')
    STYLES=[]
    for ls in LINESTYLES:
        for c in COLORS:
            STYLES.append( (c, ls) )


    ## Get file names and labels
    FILES = []
    LABELS = { "REF" : "data" }
    for a in args:
        path = a
        tmp = os.path.basename(a)
        tmp = re.sub(r'(.*)\.aida$', r'\1', tmp)
        label = "MC (%s)" % tmp
        if ":" in a:
            path, label = a.split(":", 1)
        if path != "REF":
            FILES.append(path)
        LABELS[path] = label


    ## Check that the requested files are sensible
    if (len(FILES) < 1):
        logging.error(parser.get_usage())
        exit(2)


    ## Handle a request for a reference dataset other than REF
    if opts.REF_ID != "REF":
        opts.REF_ID = os.path.abspath(opts.REF_ID)
        if not os.access(opts.REF_ID, os.R_OK):
            logging.error("Error: cannot read reference file %s" % opts.REFNAME)
            exit(2)


    def getHistos(aidafile):
        '''Get a dictionary of histograms indexed by name.'''
        if not re.match(r'.*\.aida$', aidafile):
            logging.error("Error: input file '%s' is not an AIDA file" % aidafile)
            sys.exit(2)
        aidafilepath = os.path.abspath(aidafile)
        if not os.access(aidafilepath, os.R_OK):
            logging.error("Error: cannot read from %s" % aidafile)
            sys.exit(2)

        histos, titles, xlabels, ylabels = {}, {}, {}, {}
        tree = ET.parse(aidafilepath)
        for dps in tree.findall("dataPointSet"):
            ## Get this histogram's path name
            dpsname = os.path.join(dps.get("path"), dps.get("name"))
            ## Is it a data histo?
            h = mkHistoFromDPS(dps)
            h.isdata = dpsname.upper().startswith("/REF")
            if h.isdata:
                dpsname = dpsname.replace("/REF", "")
                if not titles.has_key(dpsname):
                    titles[dpsname] = h.title
                    xlabels[dpsname] = h.xlabel
                    ylabels[dpsname] = h.ylabel
            else:
                titles[dpsname] = h.title
                xlabels[dpsname] = h.xlabel
                ylabels[dpsname] = h.ylabel
            histos[dpsname] = h
        return histos, titles, xlabels, ylabels


    ## Read histo data from files into data structures
    HISTOS = {}
    TITLES = {}
    XLABELS = {}
    YLABELS = {}
    NAMES = set()
    for f in FILES + ["REF"]:
        HISTOS[f] = {}
    for f in FILES:
        histos, titles, xlabels, ylabels = getHistos(f)
        for n, h in histos.iteritems():
            vfile = f
            if h.isdata:
                vfile = "REF"
            HISTOS[vfile][n] = h
            NAMES.add(n)
        for n, t in titles.iteritems():
            TITLES[n] = t
        for n, t in xlabels.iteritems():
            XLABELS[n] = t
        for n, t in ylabels.iteritems():
            YLABELS[n] = t


    ## Choose histos - use all histos with MC data, or restrict with a list read from file
    if opts.HISTOGRAMLIST is not None:
        newnames = []
        try:
            f = open(opts.HISTOGRAMLIST, 'r')
        except:
            logging.error("Cannot open histo list file %s" % opts.HISTOGRAMLIST)
            exit(2)
        hnames = set()
        for line in f:
            stripped = line.strip()
            if len(stripped) == 0 or stripped.startswith("#"):
                continue
            hnames.add(stripped.split()[0])
        f.close()
        NAMES = NAMES.intersection(hnames)


    ## Function to make output dirs
    def mkoutdir(outdir):
        if not os.path.exists(outdir):
            try:
                os.makedirs(outdir)
            except:
                msg = "Can't make output directory '%s'" % outdir
                logging.error(msg)
                raise Exception(msg)
        if not os.access(outdir, os.W_OK):
            msg = "Can't write to output directory '%s'" % outdir
            logging.error(msg)
            raise Exception(msg)


    ## Write out histos
    ## For < 2.4 compatibility, since Set has no 'sort' method
    NAMES = [i for i in NAMES]
    for name in sorted(NAMES):
        logging.debug("Writing histos for plot '%s'" % name)

        ## Determine the title
        try:
            title = TITLES[name]
        except:
            title = name
        title = sanitiseString(title)
        xlabel = XLABELS[name]
        ylabel = YLABELS[name]

        ## Identify contributing data files for this histo
        activefiles = []
        for f in FILES + ["REF"]:
            if HISTOS.has_key(f):
                d = HISTOS[f]
                if d.has_key(name):
                    activefiles.append(f)
        #print activefiles
        if len(activefiles) == 0:
            logging.warning("Something's wrong... somehow there's no data for histogram '%s'!" % name)
            continue

        if len(activefiles) == 1 and opts.NO_REF_ONLY:
            logging.warning("Skipping histo '%s' since only one plot is present" % name)
            continue        

        ## Identify reference file for this histo
        ref = opts.REF_ID
        if not ref in activefiles:
            ref = activefiles[0]



        ## Header
        headstr  = "# BEGIN PLOT\n"
        headstr += "Title=%s\n" % title
        headstr += "XLabel=%s\n" % xlabel
        headstr += "YLabel=%s\n" % ylabel
        headstr += "Legend=1\n"
        if len(HISTOS[ref][name].getBins()) > 1:
            headstr += "LogY=%d\n" % int(not opts.LINEAR)
        headstr += "DrawOnly=%s\n" % " ".join(activefiles)
        headstr += "RatioPlot=%d\n" % int(not opts.NORATIO)
        headstr += "RatioPlotReference=%s\n" % ref
        headstr += "RatioPlotYMin=0.5\n"
        headstr += "RatioPlotYMax=1.5\n"
        headstr += "RatioPlotYLabel=MC/data\n"
        headstr += "# END PLOT\n"

        ## Write histos
        histstrs = []
        i = 0
        for hfile in activefiles:
            histstr = '# BEGIN HISTOGRAM %s\n' % hfile
            if HISTOS[hfile][name].isdata:
                histstr += "ErrorBars=1\n"
                histstr += "PolyMarker=*\n"
                histstr += "Title=%s\n" % LABELS["REF"]
            else:
                color, style = STYLES[i % len(STYLES)]
                if opts.MC_ERRS:
                    histstr += "ErrorBars=1\n"
                histstr += 'LineColor=%s\n' % color
                histstr += 'LineStyle=%s\n' % style
                histstr += 'Title=%s\n' % LABELS[hfile]
                i += 1
            for bin in HISTOS[hfile][name].getBins():
                xmin, xmax = bin.getXRange()
                histstr += '%e\t%e\t%e\t%e\n' % (xmin, xmax, bin.yval, bin.yerr)
            histstr += "# END HISTOGRAM\n"
            histstrs.append(histstr)

        ## Choose output file name and dir
        if opts.HIER_OUTPUT:
            outdir = os.path.dirname(os.path.join(opts.OUTDIR, name[1:]))
            outfilename = '%s.dat' % os.path.basename(name)
        else:
            outdir = opts.OUTDIR
            outfilename = '%s.dat' % name.replace('/', "_")[1:]

        ## Write file
        mkoutdir(outdir)
        outfilepath = os.path.join(outdir, outfilename)
        f = open(outfilepath, 'w')
        f.write(headstr + "\n" + "\n".join(histstrs))
        f.close()
