#! /usr/bin/env python

import os, sys, re, logging

usage = """%prog - generate comparison plots

USAGE: 
  %prog [options] reffile mcfile [ref/mcfile2 ...]

TODO:
  * use fname:id syntax, remove -i option
"""

## Parse command line options
from optparse import OptionParser
parser = OptionParser(usage=usage)
parser.add_option("-o", "--outdir", dest="OUTDIR",
                  default=".", help="write data files into this directory")
parser.add_option("-l", "--histogram-list", dest="HISTOGRAMLIST",
                  default=None, help="this file contains a list of histograms to plot")
parser.add_option("--hier-out", action="store_true", dest="HIER_OUTPUT", default=False, 
                  help="write output dat files into a directory hierarchy which matches the analysis paths")
parser.add_option("--linear", action="store_true", dest="LINEAR",
                  default=False, help="plot with linear scale")
parser.add_option("--no-ratio", action="store_true", dest="NORATIO",
                  default=False, help="disable the ratio plot")
parser.add_option("--refname", dest="REFNAME",
                  default="data", help="name of reference data set")
parser.add_option("-i", "--identifiers", dest="MCIDS",
                  default=None, help="these are the plotlabels of the mchistos LABEL1:LABEL2...")
parser.add_option("-r", "--refid", dest="REFID",
                  default="data", help="the plotlabel of the ref histo")
parser.add_option("-Q", "--quiet", help="Suppress normal messages", dest="LOGLEVEL",
                  action="store_const", default=logging.INFO, const=logging.WARNING)
parser.add_option("-V", "--verbose", help="Add extra debug messages", dest="LOGLEVEL",
                  action="store_const", default=logging.INFO, const=logging.DEBUG)
opts, args = parser.parse_args()
logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")


## Line styles
STYLES=[
        ('red',   'solid'),
        ('blue',  'solid'),
        ('green', 'solid'),
        ('red',   'dashed'),
        ('blue',  'dashed'),
        ('green', 'dashed'),
        ('red',   'dotted'),
        ('blue',  'dotted'),
        ('green', 'dotted'),
       ]


def sanitiseString(s):
    #s = s.replace('_','\\_')
    #s = s.replace('^','\\^{}')
    #s = s.replace('$','\\$')
    s = s.replace('#','\\#')
    s = s.replace('%','\\%')
    return s


##############################################################
## HISTO HACKS UNTIL YODA ARRIVES...
#from professor.rivetreader import *


try:
    sorted([])
except:
    def sorted(coll):
        coll.sort()
        return coll


class Histo:
    def __init__(self):
        self._bins = []
        self.path = None
        self.name = None
        self.title = None
        self.isdata = False
        self.isref = False

    def __cmp__(self, other):
        """Sort by $path/$name string"""
        return self.fullPath() > other.fullPath()

    def __str__(self):
        out = "Histogram '%s' with %d bins\n" % (self.fullPath(), self.numBins())
        out += "Title: %s\n" % self.title
        out += "\n".join([str(b) for b in self.getBins()])
        return out

    def fullPath(self):
        return os.path.join(self.path, self.name)

    def asFlat(self):
        global headerprefix
        global opts
        out = "# BEGIN HISTOGRAM %s\n" % self.fullPath()
        out += headerprefix + "AidaPath=%s\n" % self.fullPath()
        out += headerprefix + "Title=%s\n" % self.title
        out += "## Area: %s\n" % self.area()
        out += "## Num bins: %d\n" % self.numBins()
        if opts.GNUPLOT:
            out += "## xval  \tyval    \txlow    \txhigh    \tylow     \tyhigh\n"
        else:
            out += "## xlow  \txhigh   \tyval    \tyerrminus\tyerrplus\n"
        out += "\n".join([b.asFlat() for b in self.getBins()])
        out += "\n# END HISTOGRAM"
        return out

    def numBins(self):
        return len(self._bins)

    def getBins(self):
        return sorted(self._bins)

    def setBins(self, bins):
        self._bins = bins
        return self

    def addBin(self, bin):
        self._bins.append(bin)
        return self

    def getBin(self, index):
        self._bins.sort()
        return self.getBins()[index]

    bins = property(getBins, setBins)

    def area(self):
        return sum([bin.area() for bin in self.bins])

    def __iter__(self):
        return iter(self.getBins())

    def __len__(self):
        return len(self._bins)

    def __getitem__(self, index):
        return self.getBin(index)


class Bin:
    """A simple container for a binned value with an error."""
    def __init__(self, xlow=None, xhigh=None, yval=0, yerrplus=0, yerrminus=0, focus=None):
        self.xlow = xlow
        self.xhigh= xhigh
        self.yval = yval
        self.yerrplus = yerrplus
        self.yerrminus = yerrminus
        self.focus= focus

    def __str__(self):
        out = "%e to %e: %e +- %e" % (self._xlow, self._xhigh, self._yval, self._yerr)
        return out

    def asFlat(self):
        global opts
        if opts.GNUPLOT:
            out = "%e\t%e\t%e\t%e\t%e\t%e" % (self.getBinCenter(), self.yval,
                                              self.xlow, self.xhigh, 
                                              self.yval-self.yerrminus, self.yval+self.yerrplus)
        else:
            out = "%e\t%e\t%e\t%e\t%e" % (self.xlow, self.xhigh, self.yval, self.yerrminus, self.yerrplus)
        return out

    def __cmp__(self, other):
        """Sort by mean x value (yeah, I know...)"""
        return (self.xlow + self.xhigh) > (other.xlow + other.xhigh)

    def getXRange(self):
        return (self.xlow, self.xhigh)

    def setXRange(self, xlow, xhigh):
        self.xlow = xlow
        self.xhigh = xhigh
        return self

    def getBinCenter(self):
        """Geometric middle of the bin range."""
        return self.xlow + .5*(self.xhigh - self.xlow)

    def getFocus(self):
        """Mean x-value of the bin."""
        if self.focus is not None:
            return (self.xlow + self.xhigh)/2.0
        else:
            return self.focus

    def area(self):
        return self.yval * (self.xhigh - self.xlow)

    def getYErr(self):
        """Get mean of +ve and -ve y-errors."""
        return (self.yerrplus + self.yerrminus)/2.0

    def setYErr(self, yerr):
        """Set both +ve and -ve y-errors simultaneously."""
        self.yerrplus = yerr
        self.yerrminus = yerr
        return self

    yerr = property(getYErr, setYErr)


## Try to load faster but non-standard cElementTree module
try:
    import xml.etree.cElementTree as ET
except ImportError:
    try:
        import cElementTree as ET
    except ImportError:
        import xml.etree.ElementTree as ET



def mkHistoFromDPS(dps):
    """Make a mini histo representation from an AIDA dataPointSet tag."""
    myhist = Histo()
    myhist.name = dps.get("name")
    myhist.title = dps.get("title")
    myhist.path = dps.get("path")
    points = dps.findall("dataPoint")
    numbins = len(points)
    for binnum, point in enumerate(points):
        bin = Bin()
        for d, m in enumerate(point.findall("measurement")):
            val  = float(m.get("value"))
            down = float(m.get("errorMinus"))
            up = float(m.get("errorPlus"))
            if d == 0:
                low  = val - down
                high = val + up
                bin.setXRange(low, high)
            elif d == 1:
                bin.yval = val
                bin.yerrplus = up
                bin.yerrminus = down
        myhist.addBin(bin)
    return myhist



##############################################################

if opts.REFNAME!="data":
    opts.REFNAME = os.path.abspath(opts.REFNAME)
    if not os.access(opts.REFNAME, os.R_OK):
        logging.error("Error: cannot read reference file %s" % opts.REFNAME)
        sys.exit(2)

def getHistos(aidafile):
    '''Get a dictionary of histograms indexed by name.'''
    if not re.match(r'.*\.aida$', aidafile):
        logging.error("Error: input file '%s' is not an AIDA file" % aidafile)
        sys.exit(2)
    aidafilepath = os.path.abspath(aidafile)
    if not os.access(aidafilepath, os.R_OK):
        logging.error("Error: cannot read from %s" % aidafile)
        sys.exit(2)

    histos, titles = {}, {}
    tree = ET.parse(aidafilepath)
    for dps in tree.findall("dataPointSet"):
        ## Get this histogram's path name
        dpsname = os.path.join(dps.get("path"), dps.get("name"))
        ## Is it a data histo?
        h = mkHistoFromDPS(dps)
        h.isdata = dpsname.upper().startswith("/REF")
        if h.isdata:
            dpsname = dpsname.replace("/REF", "")
        else:
            titles[dpsname] = dps.get("title")
        if ((opts.REFNAME == "data") and h.isdata) or (opts.REFNAME == aidafilepath):
            h.isref = True
        histos[dpsname] = h
    return histos, titles


## Read in ref and MC histos
FILES = args
if (len(FILES) < 1):
    logging.error(parser.get_usage())
    sys.exit(2)
HISTOS = {}
TITLES = {}
NAMES = set()
for f in FILES:
    HISTOS[f] = {}
for f in FILES:
    histos, titles = getHistos(f)
    for n, h in histos.iteritems():
        HISTOS[f][n] = h
        NAMES.add(n)
    for n, t in titles.iteritems():
        TITLES[n] = t


## Choose histos - use all histos with MC data, or restrict with a list read from file
if opts.HISTOGRAMLIST is not None:
    newnames = []
    try:
        f = open(opts.HISTOGRAMLIST, 'r')
    except:
        logging.error("Cannot open histo list file %s" % opts.HISTOGRAMLIST)
        sys.exit(2)
    hnames = set()
    for line in f:
        stripped = line.strip()
        if len(stripped) == 0 or stripped.startswith("#"):
            continue
        hnames.add(stripped.split()[0])
    f.close()
    NAMES = NAMES.intersection(hnames)


## Make output dir fn
def makeOutDir(outdir):
    if not os.access(outdir, os.R_OK):
        try:
            os.makedirs(outdir)
        except:
            logging.error("Can't make output directory '%s'" % outdir)
            sys.exit(2)
    if not os.access(outdir, os.W_OK):
        logging.error("Can't write to output directory '%s'" % outdir)
        sys.exit(2)


## Write out histos
for name in sorted(NAMES):
    logging.debug("Writing histos for plot '%s'" % name)

    ## Determine the title
    try:
        title = TITLES[name]
    except:
        title = name
    title = sanitiseString(title)

    ## Identify data files and reference
    activefiles = []
    reffile = None
    for f in FILES:
        if HISTOS[f].has_key(name):
            activefiles.append(f)
            if HISTOS[f][name].isref:
                reffile = f
    if reffile == None:
        #logging.warning("Reference '%s' not available for histo '%s'... skipping" % (opts.REFNAME, name))
        continue

    if len(activefiles) == 1:
        #logging.warning("Histo '%s' only available in the reference file ... skipping" % (name))
        continue

    ## Header
    headstr  = "# BEGIN PLOT\n"
    headstr += "Title=%s\n" % title
    headstr += "Legend=1\n"
    if len(HISTOS[reffile][name].getBins()) > 1:
        headstr += "LogY=%d\n" % int(not opts.LINEAR)
    headstr += "DrawOnly=%s\n" % " ".join(activefiles)
    headstr += "RatioPlot=%d\n" % int(not opts.NORATIO)
    headstr += "RatioPlotReference=%s\n" % reffile
    headstr += "RatioPlotYMin=0.5\n"
    headstr += "RatioPlotYMax=1.5\n"
    headstr += "RatioPlotYLabel=MC/data\n"
    headstr += "# END PLOT\n"


    ## Write histos
    histstrs = []
    i = 0
    for hfile in activefiles:
        histstr = '# BEGIN HISTOGRAM %s\n' % hfile
        if HISTOS[hfile][name].isdata:
            histstr += "ErrorBars=1\n"
            histstr += "PolyMarker=*\n"
            histstr += "Title=%s\n" % opts.REFID
        else:
            color, style = STYLES[i % len(STYLES)]
            histstr += 'LineColor=%s\n' % color
            histstr += 'LineStyle=%s\n' % style
            if (opts.MCIDS != None):
                histstr += 'Title=%s\n' % opts.MCIDS.split(":")[i]
            else:
                histstr += 'Title=MC\n'
            i += 1
        for bin in HISTOS[hfile][name].getBins():
            xmin, xmax = bin.getXRange()
            histstr += '%e\t%e\t%e\t%e\n' % (xmin, xmax, bin.yval, bin.yerr)
        histstr += "# END HISTOGRAM\n"
        histstrs.append(histstr)

    ## Write file
    if opts.HIER_OUTPUT:
        outdir = os.path.dirname(os.path.join(opts.OUTDIR, name[1:]))
        outfilename = '%s.dat' % os.path.basename(name)
    else:
        outdir = opts.OUTDIR
        outfilename = '%s.dat' % name.replace('/', "-")[1:]
    makeOutDir(outdir)
    outfilepath = os.path.join(outdir, outfilename)
    f = open(outfilepath, 'w')
    f.write(headstr + "\n" + "\n".join(histstrs))
    f.close()
