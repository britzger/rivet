#! /usr/bin/env python


## Make "set" a builtin type on Python < 2.4
if 'set' not in dir(__builtins__):
    from sets import Set as set

## Make "sorted" a builtin function on Python < 2.4
if 'sorted' not in dir(__builtins__):
    def sorted(iterable, cmp=None, key=None, reverse=None):
        rtn = iterable
        rtn.sort(cmp)#, key, reverse)
        return rtn


def sanitiseString(s):
    #s = s.replace('_','\\_')
    #s = s.replace('^','\\^{}')
    #s = s.replace('$','\\$')
    s = s.replace('#','\\#')
    s = s.replace('%','\\%')
    return s

from lighthisto import Histo, PlotParser


## Try to load faster but non-standard cElementTree module
try:
    import xml.etree.cElementTree as ET
except ImportError:
    try:
        import cElementTree as ET
    except ImportError:
        try:
            import xml.etree.ElementTree as ET
        except:
            sys.stderr.write("Can't load the ElementTree XML parser: please install it!\n")
            sys.exit(1)



if __name__ == "__main__":
    import os, sys, re, logging

    usage = """%prog - generate comparison plots

    USAGE:
      %prog [options] [REF:'Expt data'] aidafile1:'label 1' [path/to/aidafile2:label2 ...]

    TODO:
      * regex selector
      * ask/force overwrite modes
    """

    ## Try to use Psyco optimiser
    try:
        import psyco
        psyco.full()
    except ImportError:
        pass

    rivet_data_dir = os.popen('rivet-config --datadir',"r").readline().strip()
    if not rivet_data_dir:
        rivet_data_dir = ""

    ## Parse command line options
    from optparse import OptionParser
    parser = OptionParser(usage=usage)
    parser.add_option("-o", "--outdir", dest="OUTDIR",
                      default=".", help="write data files into this directory")
    parser.add_option("-l", "--histogram-list", dest="HISTOGRAMLIST",
                      default=None, help="this file contains a list of histograms to plot in the format /ANALYSIS_ID/histogramname, e.g. '/DELPHI_1996_S3430090/d01-x01-y01', on each line.")
    parser.add_option("--hier-out", action="store_true", dest="HIER_OUTPUT", default=False,
                      help="write output dat files into a directory hierarchy which matches the analysis paths")
    parser.add_option("--linear", action="store_true", dest="LINEAR",
                      default=False, help="plot with linear scale")
    parser.add_option("--logarithmic", action="store_false", dest="LINEAR",
                      default=False, help="plot with logarithmic scale (default behaviour)")
    parser.add_option("--mc-errs", action="store_true", dest="MC_ERRS",
                      default=False, help="show vertical error bars on the MC lines")
    parser.add_option("--no-ratio", action="store_true", dest="NORATIO",
                      default=False, help="disable the ratio plot")
    parser.add_option("--all", action="store_false", dest="NO_SHOW_IF_ONLY_ONE",
                      default=True, help="make plot file even if there is only one dataset to be plotted")
    parser.add_option("--no-ref-only", action="store_true", dest="NO_SHOW_IF_ONLY_ONE",
                      default=True, help="don't make plot file if there is only one dataset to be plotted")
    parser.add_option("--show-ref-only", action="store_false", dest="NO_SHOW_IF_ONLY_ONE",
                      default=True, help="make plot file even if there is only one dataset to be plotted")
    parser.add_option("--refid", dest="REF_ID",
                      default="REF", help="ID of reference data set (file path for non-REF data)")
    parser.add_option("--plot-info-dir", dest="PLOTINFODIR", action="append",
                      default=["./", rivet_data_dir], help="directory which may contain plot header information")
    parser.add_option("-Q", "--quiet", help="Suppress normal messages", dest="LOGLEVEL",
                      action="store_const", default=logging.INFO, const=logging.WARNING)
    parser.add_option("-V", "--verbose", help="Add extra debug messages", dest="LOGLEVEL",
                      action="store_const", default=logging.INFO, const=logging.DEBUG)
    opts, args = parser.parse_args()


    ## Add RIVET_*_PATH to PLOTINFO path
    def getpathvar(name):
        rtn = []
        if os.environ.has_key(name):
            rtn = [i for i in os.environ[name].split(":") if i]
        return rtn
    if os.environ.has_key("RIVET_PLOT_PATH"):
        opts.PLOTINFODIR += getpathvar("RIVET_PLOT_PATH")        
    elif os.environ.has_key("RIVET_REF_PATH"):
        opts.PLOTINFODIR += getpathvar("RIVET_REF_PATH")        

    ## Configure logging
    try:
        logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")
    except:
        pass
    h = logging.StreamHandler()
    h.setFormatter(logging.Formatter("%(message)s"))
    logging.getLogger().setLevel(opts.LOGLEVEL)
    if logging.getLogger().handlers:
        logging.getLogger().handlers[0] = h
    else:
        logging.getLogger().addHandler(h)


    ## Line styles
    COLORS = ('red', 'blue', 'blue!8!red!8!green', 'orange', 'magenta')
    LINESTYLES = ('solid', 'dashed', 'dotted')
    STYLES=[]
    for ls in LINESTYLES:
        for c in COLORS:
            STYLES.append( (c, ls) )


    ## Get file names and labels
    FILES = []
    FILELABELS = { }
    for a in args:
        path = a
        label = None
        if ":" in a:
            path, label = a.split(":", 1)
        FILES.append(path)
        FILELABELS[path] = label


    ## Check that the requested files are sensible
    if (len(FILES) < 1):
        logging.error(parser.get_usage())
        exit(2)


    ## Handle a request for a reference dataset other than REF
    if opts.REF_ID != "REF":
        opts.REF_ID = os.path.abspath(opts.REF_ID)
        if not os.access(opts.REF_ID, os.R_OK):
            logging.error("Error: cannot read reference file %s" % opts.REF_ID)
            sys.exit(2)


    def getHistos(aidafile):
        '''Get a dictionary of histograms indexed by name.'''
        if not re.match(r'.*\.aida$', aidafile):
            logging.error("Error: input file '%s' is not an AIDA file" % aidafile)
            sys.exit(2)
        aidafilepath = os.path.abspath(aidafile)
        if not os.access(aidafilepath, os.R_OK):
            logging.error("Error: cannot read from %s" % aidafile)
            sys.exit(2)

        histos, titles, xlabels, ylabels = {}, {}, {}, {}
        tree = ET.parse(aidafilepath)
        for dps in tree.findall("dataPointSet"):
            ## Get this histogram's path name
            dpsname = os.path.join(dps.get("path"), dps.get("name"))            
            h = Histo.fromDPS(dps)
            ## Is it a data histo?
            h.isdata = dpsname.upper().startswith("/REF")
            if h.isdata:
                dpsname = dpsname.replace("/REF", "")
                if not titles.has_key(dpsname):
                    titles[dpsname] = h.title
                    xlabels[dpsname] = h.xlabel
                    ylabels[dpsname] = h.ylabel
            else:
                titles[dpsname] = h.title
                xlabels[dpsname] = h.xlabel
                ylabels[dpsname] = h.ylabel
            h.expt = dpsname.split("_")[0][1:]
            histos[dpsname] = h
        return histos, titles, xlabels, ylabels


    ## Read histo data from files into data structures
    HISTOS = {}
    TITLES = {}
    XLABELS = {}
    YLABELS = {}
    LABELS = {}
    DATAFILES = {}
    NAMES = set()
    for f in FILES:
        HISTOS[f] = {}
        LABELS[f] = {}
    for f in FILES:
        histos, titles, xlabels, ylabels = getHistos(f)
        for n, h in histos.iteritems():
            if h.isdata and DATAFILES.has_key(n):
                DATAFILES[n] = f
            if FILELABELS[f] is not None:
                LABELS[f][n] = FILELABELS[f]
            else:
                if h.isdata:
                    l = "data"
                    if h.expt:
                        l = "%s data" % h.expt
                    LABELS[f][n] = l
                else:
                    tmp = os.path.basename(f)
                    tmp = re.sub(r'(.*)\.aida$', r'\1', tmp)
                    LABELS[f][n] = "MC (%s)" % tmp
            HISTOS[f][n] = h
            NAMES.add(n)
        for n, t in titles.iteritems():
            TITLES[n] = t
        for n, t in xlabels.iteritems():
            XLABELS[n] = t
        for n, t in ylabels.iteritems():
            YLABELS[n] = t


    ## Choose histos - use all histos with MC data, or restrict with a list read from file
    if opts.HISTOGRAMLIST is not None:
        newnames = []
        try:
            f = open(opts.HISTOGRAMLIST, 'r')
        except:
            logging.error("Cannot open histo list file %s" % opts.HISTOGRAMLIST)
            exit(2)
        hnames = set()
        for line in f:
            stripped = line.strip()
            if len(stripped) == 0 or stripped.startswith("#"):
                continue
            hnames.add(stripped.split()[0])
        f.close()
        NAMES = NAMES.intersection(hnames)


    ## Function to make output dirs
    def mkoutdir(outdir):
        if not os.path.exists(outdir):
            try:
                os.makedirs(outdir)
            except:
                msg = "Can't make output directory '%s'" % outdir
                logging.error(msg)
                raise Exception(msg)
        if not os.access(outdir, os.W_OK):
            msg = "Can't write to output directory '%s'" % outdir
            logging.error(msg)
            raise Exception(msg)


    ## Write out histos
    ## For < 2.4 compatibility, since Set has no 'sort' method
    NAMES = [i for i in NAMES]
    num_written = 0
    plotparser = PlotParser(filter(lambda s: len(s) > 0, opts.PLOTINFODIR))
    for name in sorted(NAMES):
        logging.debug("Writing histos for plot '%s'" % name)

        ## Determine the title
        try:
            title = TITLES[name]
        except:
            title = name
        title = sanitiseString(title)
        xlabel = XLABELS[name]
        ylabel = YLABELS[name]

        ## Identify contributing data files for this histo
        activefiles = []
        for f in FILES:
            if HISTOS.has_key(f):
                d = HISTOS[f]
                if d.has_key(name):
                    activefiles.append(f)
        #print activefiles
        if len(activefiles) == 0:
            logging.warning("Something's wrong... somehow there's no data for histogram '%s'!" % name)
            continue

        if len(activefiles) == 1 and opts.NO_SHOW_IF_ONLY_ONE:
            logging.warning("Skipping histo '%s' since only one plot is present" % name)
            continue

        ## Identify reference file for this histo
        ref = opts.REF_ID
        if ref == "REF" and DATAFILES.has_key(name):
            ref = DATAFILES[name]
        if not ref in activefiles:
            ref = activefiles[0]


        ## Header
        try:
            headers = plotparser.getHeaders(name)
        except ValueError, err:
            logging.error("Could not get plot headers: %s" % (err))
            headers = {}

        drawonlystr = ""
        for hfile in activefiles:
            drawonlystr += hfile + HISTOS[hfile][name].fullPath()+" "
        paramdefaults = {"Title" : title,
                         "XLabel" : xlabel,
                         "YLabel" : ylabel,
                         "Legend" : "1",
                         "LogY" : "%d" % int((len(HISTOS[ref][name].getBins()) > 1) and not opts.LINEAR),
                         "DrawOnly" : drawonlystr,
                         "RatioPlot" : "%d" % int(not opts.NORATIO),
                         "XTwosidedTicks" : "1",
                         "YTwosidedTicks" : "1",
                         "LegendYPos" : "0.92",
                         "RatioPlotReference" : "%s%s" % (ref, HISTOS[ref][name].fullPath())}

        headstr  = "# BEGIN PLOT\n"
        for param, default in paramdefaults.iteritems():
            if param not in headers:
                headers[param] = default
        for key, val in headers.iteritems():
            directive = "%s=%s\n" % (key, val)
            headstr += directive
        headstr += "# END PLOT\n"

        ## Special
        try:
            special = plotparser.getSpecial(name)
        except ValueError, err:
            logging.error("Could not get histo specials: %s" % (err))
            special = {}
        if special:
            headstr += "\n"
            headstr += "# BEGIN SPECIAL %s\n" %name
            headstr += special
            headstr += "# END SPECIAL\n"

        ## Write histos
        try:
            histopts = plotparser.getHistogramOptions(name)
        except ValueError, err:
            logging.error("Could not get histo options: %s" % (err))
            histopts = {}
        histstrs = []
        i = 0
        for hfile in activefiles:
            histstr = '# BEGIN HISTOGRAM %s%s\n' % (hfile, HISTOS[hfile][name].fullPath())
            if HISTOS[hfile][name].isdata:
                histstr += "ErrorBars=1\n"
                histstr += "PolyMarker=*\n"
                histstr += "Title=%s\n" % LABELS[hfile][name]
            else:
                color, style = STYLES[i % len(STYLES)]
                if opts.MC_ERRS:
                    histstr += "ErrorBars=1\n"
                histstr += 'LineColor=%s\n' % color
                histstr += 'LineStyle=%s\n' % style
                histstr += 'Title=%s\n' % LABELS[hfile][name]
                for key, val in histopts.iteritems():
                    #if key == 'ErrorBars' and opts.MC_ERRS:
                    #    continue
                    histstr += "%s=%s\n" % (key, val)
                i += 1
            for bin in HISTOS[hfile][name].getBins():
                xmin, xmax = bin.getXRange()
                histstr += '%e\t%e\t%e\t%e\n' % (xmin, xmax, bin.yval, bin.yerr)
            histstr += "# END HISTOGRAM\n"
            histstrs.append(histstr)

        ## Choose output file name and dir
        if opts.HIER_OUTPUT:
            outdir = os.path.dirname(os.path.join(opts.OUTDIR, name[1:]))
            outfilename = '%s.dat' % os.path.basename(name)
        else:
            outdir = opts.OUTDIR
            outfilename = '%s.dat' % name.replace('/', "_")[1:]

        ## Write file
        mkoutdir(outdir)
        outfilepath = os.path.join(outdir, outfilename)
        logging.debug("Writing histo '%s' to %s" % (name, outfilepath))
        f = open(outfilepath, 'w')
        f.write(headstr + "\n" + "\n".join(histstrs))
        f.close()
        num_written += 1
    logging.info("Wrote %d histo files" % num_written)
