#! /usr/bin/env python

import sys, os, logging

import lighthisto


## Make "sorted" a builtin function on Python < 2.4
if 'sorted' not in dir(__builtins__):
    def sorted(iterable, cmp=None, key=None, reverse=None):
        rtn = iterable
        rtn.sort(cmp)
        return rtn

## Add logging.log if needed
if 'log' not in dir(logging):
    def _logit(level, msg):
        l = logging.getLogger()
        l.log(level, msg)
    logging.log = _logit


## Try to load faster but non-standard cElementTree module
try:
    import xml.etree.cElementTree as ET
except ImportError:
    try:
        import cElementTree as ET
    except ImportError:
        try:
            import xml.etree.ElementTree as ET
        except:
            sys.stderr.write("Can't load the ElementTree XML parser: please install it!\n")
            sys.exit(1)
##########################################################


if __name__ == "__main__":

    rivet_data_dir=os.popen('rivet-config --datadir',"r").readline().strip()
    if not rivet_data_dir:
        rivet_data_dir=""

    ## Parse command line options
    from optparse import OptionParser, OptionGroup
    parser = OptionParser(usage="%prog aidafile [aidafile2 ...]")
    parser.add_option("-s", "--split", action="store_true", default=False,
                      help="Write each histo to a separate output file, with names based on the histo path",
                      dest="SPLITOUTPUT")
    parser.add_option("-g", "--gnuplot", action="store_true", default=False,
                      help="Provide output suitable for Gnuplot's 'plot \"foo.dat\" with xye'. Implies --split",
                      dest="GNUPLOT")
    parser.add_option("--plot-info-dir", dest="PLOTINFODIR", action="append",
                      default=["./", rivet_data_dir], help="directory which may contain plot header information")
    parser.add_option("-S", "--smart-output", action="store_true", default=False,
                      help="Write to output files with names based on the corresponding input filename",
                      dest="SMARTOUTPUT")
    parser.add_option("-m", "--match", action="append",
                      help="Only write out histograms whose $path/$name string matches these regexes",
                      dest="PATHPATTERNS")
    verbgroup = OptionGroup(parser, "Verbosity control")
    verbgroup.add_option("-V", "--verbose", action="store_const", const=logging.DEBUG, dest="LOGLEVEL",
                         default=logging.INFO, help="print debug (very verbose) messages")
    verbgroup.add_option("-Q", "--quiet", action="store_const", const=logging.WARNING, dest="LOGLEVEL",
                         default=logging.INFO, help="be very quiet")
    opts, args = parser.parse_args()


    ## Configure logging
    try:
        logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")
    except:
        pass
    h = logging.StreamHandler()
    h.setFormatter(logging.Formatter("%(message)s"))
    logging.getLogger().setLevel(opts.LOGLEVEL)
    if logging.getLogger().handlers:
        logging.getLogger().handlers[0] = h
    else:
        logging.getLogger().addHandler(h)


    ## Initialise steering variables which need a bit more care
    if opts.PATHPATTERNS is None:
        opts.PATHPATTERNS = []
    if opts.GNUPLOT:
        opts.SPLITOUTPUT = True


    ## Check that at least one file has been supplied
    if len(args) < 1:
        sys.stderr.write("Must specify at least one AIDA histogram file\n")
        sys.exit(1)

    plotparser = lighthisto.PlotParser(filter(lambda s: len(s) > 0, opts.PLOTINFODIR))


    ## Run over the files, make histos and write out those that match the patterns
    import re
    for aidafile in args:
        out = sys.stdout
        if not os.access(aidafile, os.R_OK):
            logging.error("%s can not be read" % aidafile)
            break
        try:
            tree = ET.parse(aidafile)
        except:
            logging.error("%s can not be parsed as XML" % aidafile)
            break
        histos = []
        for dps in tree.findall("dataPointSet"):
            useThisDps = True
            if len(opts.PATHPATTERNS) > 0:
                useThisDps = False
                dpspath = os.path.join(dps.get("path"), dps.get("name"))
                for regex in opts.PATHPATTERNS:
                    if re.compile(regex).search(dpspath):
                        useThisDps = True
                        break
            if useThisDps:
                hist = lighthisto.Histo.fromDPS(dps)
                plotparser.updateHistoHeaders(hist)
                histos.append(hist)
        if len(histos) > 0:
            if opts.SPLITOUTPUT:
                paper = os.path.basename(aidafile).replace(".aida", "")
                for h in sorted(histos):
                    histo = h.fullPath()[1:].replace("/", "_")
                    outfile = "%s.dat" % histo
                    if opts.SMARTOUTPUT:
                        outfile = "%s-%s" % (paper, outfile)
                    #print "Writing to", outfile
                    out = open(outfile, "w")
                    if not opts.GNUPLOT:
                        out.write(h.header() + "\n")
                    if opts.GNUPLOT:
                        out.write(h.asGnuplot() + "\n")
                    else:
                        out.write(h.asFlat() + "\n")
                    out.close()
            else:
                if opts.SMARTOUTPUT:
                    outfile = os.path.basename(aidafile).replace(".aida", ".dat")
                    out = open(outfile, "w")
                out.write("\n\n".join([h.asFlat() for h in sorted(histos)]))
                out.write("\n")
