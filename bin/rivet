#! /usr/bin/env python

import sys, os, time
import logging, signal
from optparse import OptionParser, OptionGroup

## Get version from rivet-config
version="HEAD"
try:
    version = commands.getoutput("rivet-config --version")
except:
    pass

## Description / usage message
usage="""Run Rivet analyses on inputted events from file or Unix pipe

Examples:
  %prog [options] <hepmcfile> [<hepmcfile> ...]
  my_generator -o myfifo & \ %prog [options] myfifo
  agile-runmc <genname> -n 100k | %prog [options]

ENVIRONMENT:
 * RIVET_ANALYSIS_PATH
 * RIVET_REF_PATH

TODO:
 * Use Psyco
 * Incorporate an optional AGILe mode (just reading param 
   files - no proliferation of switches)
"""


PROGPATH = sys.argv[0]
PROGNAME = os.path.basename(PROGPATH)


## Try to bootstrap the Python path
import commands
try:
    modname=sys.modules[__name__].__file__
    binpath=modname[:modname.rfind("/")]
    rivetpypath = commands.getoutput(binpath+"/rivet-config --pythonpath")
    sys.path.append(rivetpypath)
except:
    pass


## Try importing non-standard HEP Python packages
try:
    import rivet
except:
    sys.stderr.write(PROGNAME + " requires the 'rivet' Python module\n");
    sys.exit(1)


## Parse command line options
parser = OptionParser(usage=usage, version="rivet v%s" % version)
parser.add_option("-n", "--nevts", dest="MAXEVTNUM", type=int,
                  default=None, metavar="NUM", 
                  help="max number of events to read.")
parser.add_option("-a", "--analysis", dest="ANALYSES", action="append",
                  default=[], metavar="ANA",
                  help="add an analysis to the processing list.")
parser.add_option("-A", "--all-analyses", dest="ALL_ANALYSES", action="store_true",
                  default=False, help="add all analyses to the processing list.")
#parser.add_option("--list-options", dest="LIST_OPTIONS", action="store_true",
#                  default=False, help="show the available option switches for auto-parsing by 'complete'")
parser.add_option("--list-analyses", dest="LIST_ANALYSES", action="store_true",
                  default=False, help="show the list of available analyses' names. With -V, it shows the descriptions, too")
parser.add_option("--list-used-analyses", action="store_true", dest="LIST_USED_ANALYSES", 
                  default=False, help="list the analyses used by this command (after subtraction of inappropriate ones)")
parser.add_option("--show-analysis", dest="SHOW_ANALYSES", action="append",
                  default=[], help="show the details of an analysis")
parser.add_option("-x", "--cross-section", dest="CROSS_SECTION", type=float,
                  default=None, metavar="XS",
                  help="specify the signal process cross-section in pb")
## TODO: allow user to specify histo file extension
parser.add_option("-H", "--histo-file", dest="HISTOFILE", 
                  default="Rivet", help="specify the output histo file path")
verbgroup = OptionGroup(parser, "Verbosity control")
parser.add_option("-l", dest="NATIVE_LOG_STRS", action="append",
                  default=[], help="set a log level in the Rivet library")
verbgroup.add_option("-V", "--verbose", action="store_const", const=logging.DEBUG, dest="LOGLEVEL",
                     default=logging.INFO, help="print debug (very verbose) messages")
verbgroup.add_option("-Q", "--quiet", action="store_const", const=logging.WARNING, dest="LOGLEVEL",
                     default=logging.INFO, help="be very quiet")
parser.add_option_group(verbgroup)
opts, args = parser.parse_args()
logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")


## Control native Rivet library logger
for l in opts.NATIVE_LOG_STRS:
    try:
        name, level = l.split("=")
        ## Get right error type
        LEVEL = level.upper()
        if LEVEL == "TRACE":
            level = rivet.Log.TRACE
        elif LEVEL == "DEBUG":
            level = rivet.Log.DEBUG
        elif LEVEL == "INFO":
            level = rivet.Log.INFO
        elif LEVEL == "WARNING":
            level = rivet.Log.WARNING
        elif LEVEL == "ERROR":
            level = rivet.Log.ERROR
        else:
            level = int(level)
        ## Fix name
        if name != "Rivet" and not name.startswith("Rivet."):
            name = "Rivet." + name
        #print name, level
        rivet.Log.setLogLevel(name, level)
    except:
        logging.warning("Couldn't process logging string '%s'" % l)


## Print the available CLI options!
#if opts.LIST_OPTIONS:
#    for o in parser.option_list:
#        print o.get_opt_string()
#    sys.exit(0)


## Set up signal handling
RECVD_KILL_SIGNAL = None
def handleKillSignal(signum, frame):
    "Declare us as having been signalled, and return to default handling behaviour"
    logging.critical("Signal handler called with signal " + str(signum))
    RECVD_KILL_SIGNAL = signum
    signal.signal(signum, signal.SIG_DFL)
## Signals to handle
signal.signal(signal.SIGTERM, handleKillSignal);
signal.signal(signal.SIGHUP,  handleKillSignal);
signal.signal(signal.SIGINT,  handleKillSignal);
signal.signal(signal.SIGUSR2, handleKillSignal);


## List of analyses
all_analyses = rivet.AnalysisLoader.allAnalysisNames()
if opts.LIST_ANALYSES:
    for aname in all_analyses:
        msg = aname
        if opts.LOGLEVEL == logging.DEBUG:
            a = rivet.AnalysisLoader.getAnalysis(aname)
            msg = "%-25s %s" % (aname, "  " + a.description())
        print msg
    sys.exit(0)


## Show analyses' details
if len(opts.SHOW_ANALYSES) > 0:
    toshow = set()
    for i, a in enumerate(opts.SHOW_ANALYSES):
        a_up = a.upper()
        if a_up in all_analyses:
            toshow.add(a_up)
        else:
            ## Treat as a regex
            import re
            regex = re.compile(a)
            for ana in all_analyses:
                if regex.search(ana):
                    toshow.add(ana)

    ## Show the matching analyses' details
    for name in sorted(toshow):
        ana = rivet.AnalysisLoader.getAnalysis(name)
        print ""
        print ana.name()
        print len(ana.name()) * "="
        print ""
        print "Spires ID: %s" % ana.spiresId()
        print "Spires URL: http://www.slac.stanford.edu/spires/find/hep/www?rawcmd=key+%s" % ana.spiresId()
        print "Experiment: %s" % ana.experiment()
        print "Year of publication: %s" % ana.year()
        #print ana.getAuthor()
        #print ana.getInstructions()
        #print ana.getCuts()
        print ""
        print "Description:\n  " + ana.description()
        print ""
        print "References:"
        for r in ana.references():
            print "  %s" % r
        if i+1 < len(opts.SHOW_ANALYSES):
            print "\n"
    sys.exit(0)


## Identify HepMC files/streams
## TODO: check readability, deal with stdin
if len(args) > 0:
    HEPMCFILES = args
else:
    HEPMCFILES = ["-"]


## Set up analysis handler
ah = rivet.AnalysisHandler(opts.HISTOFILE)
if opts.ALL_ANALYSES:
    opts.ANALYSES = all_analyses
for a in opts.ANALYSES:
    a_up = a.upper()
    ## Print warning message and exit if not a valid analysis name
    if not a_up in all_analyses:
        print "'%s' is not a valid analysis. Available analyses are:" % a_up
        for aa in all_analyses:
            print "    %s" % aa
        sys.exit(1)
    logging.debug("Adding analysis '%s'" % a_up)
    ah.addAnalysis(a_up)
ah.init()
        

## Event number logging
def logNEvt(n):
    nevtloglevel = logging.DEBUG
    if n % 10 == 0:
        nevtloglevel = logging.DEBUG + 5
    if n % 100 == 0:
        nevtloglevel = logging.INFO
    if n % 200 == 0:
        nevtloglevel = logging.INFO + 5
    if n % 500 == 0:
        nevtloglevel = logging.WARNING
    if n % 1000 == 0:
        nevtloglevel = logging.WARNING + 5
    if n % 10000 == 0:
        nevtloglevel = logging.CRITICAL
    logging.log(nevtloglevel, "Event %d" % n)


## Here is where we first need the Python HepMC interface
try:
    import hepmc
except:
    sys.stderr.write(PROGNAME + " requires the 'hepmc' Python module\n");
    sys.exit(1)

## Read and process events
EVTNUM = 0
starttime = time.time()
for evtfile in HEPMCFILES:
    logging.info("Reading events from '%s'" % evtfile)
    r = hepmc.IO_GenEvent(evtfile, "r")
    while opts.MAXEVTNUM is None or EVTNUM < opts.MAXEVTNUM:
        EVTNUM += 1
        logNEvt(EVTNUM)
        if r.rdstate() != 0:
            logging.warning("Read error on file '%s'" % evtfile)
            break
        evt = r.get_next_event()
        ## TODO: Use units
        #evt.use_units(GEV, MM)

        ## Use the first event to check the analyses' beam compatibility
        if EVTNUM == 1:
            firstBeamIds = rivet.beamIds(evt)
            logging.info("First event beam IDs = %s" % str(firstBeamIds))
            num_anas_requested = len(ah.analysisNames())
            ah.removeIncompatibleAnalyses(firstBeamIds)
            if num_anas_requested > 0 and len(ah.analysisNames()) == 0:
                logging.warning("All analyses were incompatible with the first event's beams")
                logging.error("Exiting, since this probably isn't intentional!")
                sys.exit(2)

            ## TODO: write to file? exit?
            if opts.LIST_USED_ANALYSES:
                for an in ah.analysisNames():
                    print an

            ## Cross-section
            if ah.needCrossSection():
                xs = opts.CROSS_SECTION
                if xs is None:
                    try:
                        xs = raw_input("Please specify the cross-section in pb: ")
                        xs = float(xs)
                        if xs <= 0:
                            raise ValueError("Cross-section %e is not a positive number")
                    except:
                        logging.error("Invalid cross-section: %s" % xs)
                        sys.exit(2)
                ah.setCrossSection(xs)

            ## If it's the first event, reinitialize the start time since 
            ## we could have been waiting for user input:
            starttime = time.time()

        ## All is well... do the analysis
        ah.analyze(evt);
        if RECVD_KILL_SIGNAL is not None:
            logging.critical("Leaving event loop early due to signal " + str(RECVD_KILL_SIGNAL))
            break
    if RECVD_KILL_SIGNAL is not None:
        break
logging.info("Finished event loop")


## Did we get enough events?
if EVTNUM < opts.MAXEVTNUM:
    logging.warning("Sampled fewer events (%d) than expected (%d)" % (EVTNUM, opts.MAXEVTNUM))


## Finalize and write out data file
ah.finalize()
ah.commitData();

endtime = time.time()
delta_t = endtime - starttime
logging.info("Time elapsed: %0.2f seconds" % delta_t)
