#! /usr/bin/env python

## 
## This program is copyright by Hendrik Hoeth <hoeth@linta.de>. It may be used
## for scientific and private purposes. Patches are welcome, but please don't
## redistribute changed versions yourself.
## 
## $Date$
## $Revision$
## 


# TODO:
# - Angabe von manuellen tickmarks und ticklabeln schoener machen.
#   Im Moment ist die Syntax noch eine mit tab getrennte Liste von Wert und Beschriftung


import os, sys, logging
import tempfile
import getopt
import string
from math import *


class Inputdata:
    def __init__(self, filename):
        self.histos = {}
        self.special = {}
        self.functions = {}
        f = open(filename+'.dat')
        global is2dim
        is2dim=False
        for line in f:
            if (line.count('#',0,1)):
                if (line.count('BEGIN PLOT')):
                    self.read_input(f);
                if (line.count('BEGIN SPECIAL')):
                    self.special[line.split('BEGIN SPECIAL', 1)[1].strip()] = Special(f)
                if (line.count('BEGIN HISTOGRAM')):
                    self.histos[line.split('BEGIN HISTOGRAM', 1)[1].strip()] = Histogram(f)
                if (line.count('BEGIN FUNCTION')):
                    self.functions[line.split('BEGIN FUNCTION', 1)[1].strip()] = Function(f)

        global plotsizex
        global plotsizey
        if self.description.has_key('PlotSize') and self.description['PlotSize']!='':
            plotsizex,plotsizey=self.description['PlotSize'].split(',')
            plotsizex=float(plotsizex)
            plotsizey=float(plotsizey)
        else:
            plotsizex=10.
            plotsizey=6.

        global ratioplotsizey
        if self.description.has_key('RatioPlot') and self.description['RatioPlot']=='1':
            if self.description.has_key('RatioPlotYSize') and self.description['RatioPlotYSize']!='':
                ratioplotsizey=float(self.description['RatioPlotYSize'])
            else:
                ratioplotsizey=3.
        else:
            ratioplotsizey=0.

        global logx
        if self.description.has_key('LogX') and self.description['LogX']=='1':
            logx=True
        else:
            logx=False

        global logy
        if self.description.has_key('LogY') and self.description['LogY']=='1':
            logy=True
        else:
            logy=False

        if self.description.has_key('Stack'):
            foo=[]
            for i in self.description['Stack'].strip().split():
                if i in self.histos.keys():
                    foo.append(i)
            previous=''
            for i in foo:
                if previous!='':
                    self.histos[i].add(self.histos[previous])
                previous=i
        foo=[]
        if self.description.has_key('DrawOnly'):
            for i in self.description['DrawOnly'].strip().split():
                if i in self.histos.keys(): foo.append(i)
        else:
            foo=self.histos.keys()
        self.description['DrawOnly']=foo
    def read_input(self, f):
        self.description = {}
        for line in f:
            if (line.count('#',0,1)):
                if (line.count('END PLOT')):
                    break
            else:
                line = line.rstrip()
                if (line.count('=')):
                    linearray = line.split('=', 1)
                    self.description[linearray[0]] = linearray[1]



class Plot:
    def __init__(self, inputdata):
        pass

    def set_borders(self, inputdata):
        self.set_xmax(inputdata)
        self.set_xmin(inputdata)
        self.set_ymax(inputdata)
        self.set_ymin(inputdata)
        self.set_zmax(inputdata)
        self.set_zmin(inputdata)

    def set_xmin(self,inputdata):
        global xmin
        if inputdata.description.has_key('XMin'):
            xmin = float(inputdata.description['XMin'])
        else:
            foo=[]
            for i in inputdata.description['DrawOnly']:
                foo.append(inputdata.histos[i].getXMin())
            xmin=min(foo)

    def set_xmax(self,inputdata):
        global xmax
        if inputdata.description.has_key('XMax'):
            xmax = float(inputdata.description['XMax'])
        else:
            foo=[]
            for i in inputdata.description['DrawOnly']:
                foo.append(inputdata.histos[i].getXMax())
            xmax=max(foo)

    def set_ymin(self,inputdata):
        global ymin, ymax
        if inputdata.description.has_key('YMin'):
            ymin = float(inputdata.description['YMin'])
        else:
            foo=[]
            for i in inputdata.description['DrawOnly']:
                foo.append(inputdata.histos[i].getYMin(xmin, xmax))
            if is2dim:
                ymin=min(foo)
            else:
                if min(foo) > -1e-4:
                    ymin = 0
                else:
                    ymin = 1.1*min(foo)
                if logy:
                    if opts.FULL_RANGE:
                        ymin = min(foo)/1.7
                    else:
                        ymin = max(min(foo)/1.7, 2e-4*ymax)
                if ymin==ymax:
                    ymin-=1
                    ymax+=1

    def set_ymax(self,inputdata):
        global ymax
        if inputdata.description.has_key('YMax'):
            ymax = float(inputdata.description['YMax'])
        else:
            foo=[]
            for i in inputdata.description['DrawOnly']:
                foo.append(inputdata.histos[i].getYMax(xmin, xmax))
            if is2dim:
                ymax=max(foo)
            else:
                if logy:
                    ymax=1.7*max(foo)
                else:
                    ymax=1.1*max(foo)

    def set_zmin(self,inputdata):
        global zmin
        if inputdata.description.has_key('ZMin'):
            zmin = float(inputdata.description['ZMin'])
        else:
            foo=[]
            for i in inputdata.description['DrawOnly']:
                foo.append(inputdata.histos[i].getZMin())
            zmin=min(foo)

    def set_zmax(self,inputdata):
        global zmax
        if inputdata.description.has_key('ZMax'):
            zmax = float(inputdata.description['ZMax'])
        else:
            foo=[]
            for i in inputdata.description['DrawOnly']:
                foo.append(inputdata.histos[i].getZMax())
            zmax=min(foo)

    def draw(self):
        pass

    def write_header(self,inputdata):
        if inputdata.description.has_key('LeftMargin') and inputdata.description['LeftMargin']!='':
            leftmargin = float(inputdata.description['LeftMargin'])
        else:
            leftmargin = 1.25
        if inputdata.description.has_key('RightMargin') and inputdata.description['RightMargin']!='':
            rightmargin = float(inputdata.description['RightMargin'])
        else:
            rightmargin = 0.35
        if inputdata.description.has_key('TopMargin') and inputdata.description['TopMargin']!='':
            topmargin = float(inputdata.description['TopMargin'])
        else:
            topmargin = 0.65
        if inputdata.description.has_key('BottomMargin') and inputdata.description['BottomMargin']!='':
            bottommargin = float(inputdata.description['BottomMargin'])
        else:
            bottommargin = 0.95
        papersizex = plotsizex + 0.1 + leftmargin + rightmargin
        papersizey = plotsizey + ratioplotsizey + 0.1 + topmargin + bottommargin
        #
        out = ""
        out += '\\documentclass{article}\n'
        if opts.OUTPUT_FONT == "MINION":
            out += ('\\usepackage{minion}\n')
        elif opts.OUTPUT_FONT == "PALATINO_OSF":
            out += ('\\usepackage[osf,sc]{mathpazo}\n')
        elif opts.OUTPUT_FONT == "PALATINO":
            out += ('\\usepackage{mathpazo}\n')
        out += ('\\usepackage{pst-all}\n')
        out += ('\\selectcolormodel{rgb}\n')
        out += ('\\usepackage{amsmath}\n')
        out += ('\\usepackage{amssymb}\n')
        out += ('\\usepackage{underscore}\n')
        out += ('\\usepackage{relsize}\n')
        out += ('\\usepackage[dvips,\n')
        out += ('  left=%4.3fcm, right=0cm,\n' %(leftmargin-0.55,))
        out += ('  top=%4.3fcm,  bottom=0cm,\n' %(topmargin+0.05,))
        out += ('  paperwidth=%scm,paperheight=%scm\n' %(papersizex,papersizey))
        out += (']{geometry}\n')
        out += ('\\begin{document}\n')
        out += ('\\pagestyle{empty}\n')
        out += ('\\SpecialCoor\n')
        out += ('\\psset{xunit=%scm,yunit=%scm}\n' %(plotsizex,plotsizey))
        out += ('\\begin{pspicture}(0,0)(1,1)\n')
        if is2dim:
            out += ('\\definecolorseries{gradientcolors}{hsb}{grad}[rgb]{0,0,1}{-.700,0,0}\n')
            out += ('\\resetcolorseries[130]{gradientcolors}\n')
        return out

    def write_footer(self):
        out = ""
        out += ('\\end{pspicture}\n')
        out += ('\\end{document}\n')
        return out



class MainPlot(Plot):
    def __init__(self, inputdata):
        self.set_borders(inputdata)
        global coors
        coors = Coordinates()

    def draw(self, inputdata):
        out = ""
        out += self.write_header(inputdata)
        out += self._draw(inputdata)
        return out

    def _draw(self, inputdata):
        out = ""
        if inputdata.description.has_key('DrawSpecialFirst') and inputdata.description['DrawSpecialFirst']=='1':
            for i in inputdata.special.keys():
                out += inputdata.special[i].draw()
            if inputdata.description.has_key('DrawFunctionFirst') and inputdata.description['DrawFunctionFirst']=='1':
                for i in inputdata.functions.keys():
                    out += inputdata.functions[i].draw()
                for i in inputdata.description['DrawOnly']:
                    out += inputdata.histos[i].draw()
            else:
                for i in inputdata.description['DrawOnly']:
                    out += inputdata.histos[i].draw()
                for i in inputdata.functions.keys():
                    out += inputdata.functions[i].draw()
        else:
            if inputdata.description.has_key('DrawFunctionFirst') and inputdata.description['DrawFunctionFirst']=='1':
                for i in inputdata.functions.keys():
                    out += inputdata.functions[i].draw()
                for i in inputdata.description['DrawOnly']:
                    out += inputdata.histos[i].draw()
            else:
                for i in inputdata.description['DrawOnly']:
                    out += inputdata.histos[i].draw()
                for i in inputdata.functions.keys():
                    out += inputdata.functions[i].draw()
            for i in inputdata.special.keys():
                out += inputdata.special[i].draw()
        if inputdata.description.has_key('Legend') and inputdata.description['Legend']=='1':
            legend = Legend(inputdata.description,inputdata.histos,inputdata.functions)
            out += legend.draw()
        frame = Frame()
        out += frame.draw()

        if inputdata.description.has_key('XMajorTickMarks') and inputdata.description['XMajorTickMarks']!='':
            xcustommajortickmarks=int(inputdata.description['XMajorTickMarks'])
        else:
            xcustommajortickmarks=-1
        if inputdata.description.has_key('XMinorTickMarks') and inputdata.description['XMinorTickMarks']!='':
            xcustomminortickmarks=int(inputdata.description['XMinorTickMarks'])
        else:
            xcustomminortickmarks=-1
        xcustomticks=[]
        if inputdata.description.has_key('XCustomTicks') and inputdata.description['XCustomTicks']!='':
            FOO=inputdata.description['XCustomTicks'].strip().split('\t')
            if not len(FOO)%2:
                for i in range(0,len(FOO),2):
                    xcustomticks.append({'Value': float(FOO[i]), 'Label': FOO[i+1]})
        xticks = XTicks()
        if inputdata.description.has_key('RatioPlot') and inputdata.description['RatioPlot']=='1':
            drawlabels=False
        else:
            drawlabels=True
        out += xticks.draw(custommajortickmarks=xcustommajortickmarks,\
                               customminortickmarks=xcustomminortickmarks,\
                               customticks=xcustomticks,drawlabels=drawlabels)

        if inputdata.description.has_key('YMajorTickMarks') and inputdata.description['YMajorTickMarks']!='':
            ycustommajortickmarks=int(inputdata.description['YMajorTickMarks'])
        else:
            ycustommajortickmarks=-1
        if inputdata.description.has_key('YMinorTickMarks') and inputdata.description['YMinorTickMarks']!='':
            ycustomminortickmarks=int(inputdata.description['YMinorTickMarks'])
        else:
            ycustomminortickmarks=-1
        ycustomticks=[]
        if inputdata.description.has_key('YCustomTicks') and inputdata.description['YCustomTicks']!='':
            FOO=inputdata.description['YCustomTicks'].strip().split('\t')
            if not len(FOO)%2:
                for i in range(0,len(FOO),2):
                    ycustomticks.append({'Value': float(FOO[i]), 'Label': FOO[i+1]})
        yticks = YTicks()
        out += yticks.draw(custommajortickmarks=ycustommajortickmarks,\
                               customminortickmarks=ycustomminortickmarks,\
                               customticks=ycustomticks)

        labels = Labels(inputdata.description)
        if inputdata.description.has_key('RatioPlot') and inputdata.description['RatioPlot']=='1':
            out += labels.draw(['Title','YLabel'])
        else:
            out += labels.draw(['Title','XLabel','YLabel'])
        return out



class RatioPlot(Plot):
    def __init__(self, inputdata):
        if inputdata.description.has_key('RatioPlot') and inputdata.description['RatioPlot']=='1':
            self.refdata=inputdata.description['RatioPlotReference']
            global plotsizey
            plotsizey=ratioplotsizey
            global logy
            logy=False
            if inputdata.description.has_key('RatioPlotYMin'):
                inputdata.description['YMin']=inputdata.description['RatioPlotYMin']
            if inputdata.description.has_key('RatioPlotYMax'):
                inputdata.description['YMax']=inputdata.description['RatioPlotYMax']
            if not inputdata.description.has_key('RatioPlotErrorBandColor'):
                inputdata.description['RatioPlotErrorBandColor']='yellow'
            inputdata.histos[self.refdata].description['ErrorBandColor']=inputdata.description['RatioPlotErrorBandColor']
            inputdata.histos[self.refdata].description['ErrorBands']='1'
            inputdata.histos[self.refdata].description['ErrorBars']='0'
            inputdata.histos[self.refdata].description['LineStyle']='solid'
            inputdata.histos[self.refdata].description['LineColor']='black'
            inputdata.histos[self.refdata].description['LineWidth']='0.3pt'
            inputdata.histos[self.refdata].description['PolyMarker']=''
            self.calculate_ratios(inputdata)
            self.set_borders(inputdata)
            global coors
            coors = Coordinates()

    def draw(self, inputdata):
        out = ""
        out += ('\n%\n% RatioPlot\n%\n')
        out += ('\\psset{yunit=%scm}\n' %(plotsizey))
        out += ('\\rput(0,-1){%\n')
        out += self._draw(inputdata)
        out += ('}\n') 
        out += self.write_footer()
        return out

    def calculate_ratios(self,inputdata):
        foo=inputdata.description['DrawOnly'].pop(inputdata.description['DrawOnly'].index(self.refdata))
        inputdata.description['DrawOnly'].insert(0,foo)
        for i in inputdata.description['DrawOnly']:
            if i!=self.refdata:
                inputdata.histos[i].divide(inputdata.histos[self.refdata])
        inputdata.histos[self.refdata].divide(inputdata.histos[self.refdata])

    def _draw(self, inputdata):
        out = ""
        for i in inputdata.description['DrawOnly']:
            out += inputdata.histos[i].draw()

        frame = Frame()
        out += frame.draw()

        if inputdata.description.has_key('XMajorTickMarks') and inputdata.description['XMajorTickMarks']!='':
            xcustommajortickmarks=int(inputdata.description['XMajorTickMarks'])
        else:
            xcustommajortickmarks=-1
        if inputdata.description.has_key('XMinorTickMarks') and inputdata.description['XMinorTickMarks']!='':
            xcustomminortickmarks=int(inputdata.description['XMinorTickMarks'])
        else:
            xcustomminortickmarks=-1
        xcustomticks=[]
        if inputdata.description.has_key('XCustomTicks') and inputdata.description['XCustomTicks']!='':
            FOO=inputdata.description['XCustomTicks'].strip().split('\t')
            if not len(FOO)%2:
                for i in range(0,len(FOO),2):
                    xcustomticks.append({'Value': float(FOO[i]), 'Label': FOO[i+1]})
        xticks = XTicks()
        out += xticks.draw(custommajortickmarks=xcustommajortickmarks,\
                               customminortickmarks=xcustomminortickmarks,\
                               customticks=xcustomticks)

        if inputdata.description.has_key('YMajorTickMarks') and inputdata.description['YMajorTickMarks']!='':
            ycustommajortickmarks=int(inputdata.description['YMajorTickMarks'])
        else:
            ycustommajortickmarks=-1
        if inputdata.description.has_key('YMinorTickMarks') and inputdata.description['YMinorTickMarks']!='':
            ycustomminortickmarks=int(inputdata.description['YMinorTickMarks'])
        else:
            ycustomminortickmarks=-1
        ycustomticks=[]
        if inputdata.description.has_key('YCustomTicks') and inputdata.description['YCustomTicks']!='':
            FOO=inputdata.description['YCustomTicks'].strip().split('\t')
            if not len(FOO)%2:
                for i in range(0,len(FOO),2):
                    ycustomticks.append({'Value': float(FOO[i]), 'Label': FOO[i+1]})
        yticks = YTicks()
        out += yticks.draw(custommajortickmarks=ycustommajortickmarks,\
                               customminortickmarks=ycustomminortickmarks,\
                               customticks=ycustomticks)

        labels = Labels(inputdata.description)
        out += labels.draw(['XLabel','RatioPlotYLabel'])

        return out


class Legend:
    def __init__(self, description, histos, functions):
        self.histos = histos
        self.functions = functions
        self.description = description

    def draw(self):
        out = ""
        out += '\n%\n% Legend\n%\n'
        out += '\\rput[tr](%s,%s){%%\n' % (self.getLegendXPos(), self.getLegendYPos())
        ypos = -0.05*6/plotsizey
        foo=[]
        if self.description.has_key('LegendOnly'):
            for i in self.description['LegendOnly'].strip().split():
                if i in self.histos.keys() or i in self.functions.keys():
                    foo.append(i)
        else:
            foo=self.description['DrawOnly']+self.functions.keys()

        for i in foo:
            if self.histos.has_key(i):
                drawobject=self.histos[i]
            elif self.functions.has_key(i):
                drawobject=self.functions[i]
            else:
                continue
            title = drawobject.getTitle()
            if title == '':
                continue
            else:
                out += ('\\rput[Bl](-0.35,' + str(ypos) + '){' + title + '}\n')
                out += ('\\rput[Bl](-0.35,%s){%s\n' %(ypos,'%'))
                if drawobject.getErrorBands():
                    out += ('\\psframe[linecolor=%s,fillstyle=solid,fillcolor=%s]' %(drawobject.getErrorBandColor(),drawobject.getErrorBandColor()))
                    out += ('(-0.10, 0.033)(-0.02, 0.001)\n')
                out += ('\\psline[linestyle=' + drawobject.getLineStyle() \
                            + ', linecolor=' + drawobject.getLineColor() \
                            + ', linewidth=' + drawobject.getLineWidth())
                if drawobject.getLineDash()!='':
                    out += (', dash=' + drawobject.getLineDash())
                if drawobject.getFillStyle()!='none':
                    out += (', fillstyle=' + drawobject.getFillStyle() \
                                + ', fillcolor='  + drawobject.getFillColor() \
                                + ', hatchcolor=' + drawobject.getHatchColor() \
                                + '](-0.10, 0.030)(-0.02, 0.030)(-0.02, 0.004)(-0.10, 0.004)(-0.10, 0.030)\n')
                else:
                    out += ('](-0.10, 0.016)(-0.02, 0.016)\n')
                if drawobject.getPolyMarker() != '':
                    out += ('  \\psdot[dotstyle=' + drawobject.getPolyMarker() \
                                + ', dotsize='    + drawobject.getDotSize()   \
                                + ', dotscale='   + drawobject.getDotScale()  \
                                + ', linecolor='  + drawobject.getLineColor() \
                                + ', linewidth='  + drawobject.getLineWidth() \
                                + ', linestyle='  + drawobject.getLineStyle() \
                                + ', fillstyle='  + drawobject.getFillStyle() \
                                + ', fillcolor='  + drawobject.getFillColor() \
                                + ', hatchcolor=' + drawobject.getHatchColor())
                    if drawobject.getFillStyle()!='none':
                        out += ('](-0.06, 0.028)\n')
                    else:
                        out += ('](-0.06, 0.016)\n')
                out += ('}\n')
                ypos -= 0.075*6/plotsizey
        if self.description.has_key('CustomLegend'):
            for i in self.description['CustomLegend'].strip().split('\\\\'):
                out += ('\\rput[Bl](-0.35,' + str(ypos) + '){' + i + '}\n')
                ypos -= 0.075*6/plotsizey
        out += ('}\n')
        return out

    def getLegendXPos(self):
        if self.description.has_key('LegendXPos'):
            return self.description['LegendXPos']
        else:
            return '0.98'

    def getLegendYPos(self):
        if self.description.has_key('LegendYPos'):
            return self.description['LegendYPos']
        else:
            return '0.98'
            


class Labels:
    def __init__(self, description):
        self.description = description

    def draw(self, axis=[]):
        out = ""
        out += ('\n%\n% Labels\n%\n')
        if self.description.has_key('Title') and (axis.count('Title') or axis==[]):
            out += ('\\rput(0,1){\\rput[lB](0, 1.7\\labelsep){\\normalsize '+self.description['Title']+'}}\n')
        if self.description.has_key('XLabel') and (axis.count('XLabel') or axis==[]):
            xlabelsep=4.7
            if self.description.has_key('XLabelSep'):
                xlabelsep=float(self.description['XLabelSep'])
            out += ('\\rput(1,0){\\rput[rB](0,-%4.3f\\labelsep){\\normalsize '%(xlabelsep) +self.description['XLabel']+'}}\n')
        if self.description.has_key('YLabel') and (axis.count('YLabel') or axis==[]):
            ylabelsep=5.3
            if self.description.has_key('YLabelSep'):
                ylabelsep=float(self.description['YLabelSep'])
            out += ('\\rput(0,1){\\rput[rB]{90}(-%4.3f\\labelsep,0){\\normalsize '%(ylabelsep) +self.description['YLabel']+'}}\n')
        if self.description.has_key('RatioPlotYLabel') and (axis.count('RatioPlotYLabel') or axis==[]):
            ylabelsep=5.3
            if self.description.has_key('YLabelSep'):
                ylabelsep=float(self.description['YLabelSep'])
            out += ('\\rput(0,1){\\rput[rB]{90}(-%4.3f\\labelsep,0){\\normalsize '%(ylabelsep) +self.description['RatioPlotYLabel']+'}}\n')
        return out



class Special:
    def __init__(self, f):
        self.read_input(f)

    def read_input(self, f):
        self.description = {}
        self.data = []
        for line in f:
            if (line.count('#',0,1)):
                if (line.count('END SPECIAL')):
                    break
            else:
                self.data.append(line)

    def draw(self):
        out = ""
        out += ('\n%\n% Special\n%\n')
        for i in range(len(self.data)):
            if self.data[i].count('\\physicscoor'):
                line = self.data[i].split('\\physicscoor')
                self.data[i] = line[0]
                for j in range(1,len(line)):
                    coor = line[j].split(')')[0].lstrip(' (').split(',')
                    self.data[i] +=   '(' + coors.strphys2frameX(float(coor[0])) \
                                    + ',' + coors.strphys2frameY(float(coor[1])) \
                                    + ')' + line[j].split(')',1)[1]
            out += self.data[i]+'\n'
        return out



class DrawableObject:
    def __init__(self, f):
        pass

    def getTitle(self):
        if self.description.has_key('Title'):
            return self.description['Title']
        else:
            return ''

    def getLineStyle(self):
        if self.description.has_key('LineStyle'):
            return self.description['LineStyle']
        else:
            return 'solid'

    def getLineDash(self):
        if self.description.has_key('LineDash'):
            return self.description['LineDash']
        else:
            return ''

    def getLineWidth(self):
        if self.description.has_key('LineWidth'):
            return self.description['LineWidth']
        else:
            return '0.8pt'

    def getLineColor(self):
        if self.description.has_key('LineColor'):
            return self.description['LineColor']
        else:
            return 'black'

    def getFillColor(self):
        if self.description.has_key('FillColor'):
            return self.description['FillColor']
        else:
            return 'white'

    def getHatchColor(self):
        if self.description.has_key('HatchColor'):
            return self.description['HatchColor']
        else:
            return 'black'

    def getFillStyle(self):
        if self.description.has_key('FillStyle'):
            return self.description['FillStyle']
        else:
            return 'none'

    def getPolyMarker(self):
        if self.description.has_key('PolyMarker'):
            return self.description['PolyMarker']
        else:
            return ''

    def getDotSize(self):
        if self.description.has_key('DotSize'):
            return self.description['DotSize']
        else:
            return '2pt 2'

    def getDotScale(self):
        if self.description.has_key('DotScale'):
            return self.description['DotScale']
        else:
            return '1'

    def getErrorBars(self):
        if self.description.has_key('ErrorBars'):
            return bool(int(self.description['ErrorBars']))
        else:
            return False

    def getErrorBands(self):
        if self.description.has_key('ErrorBands'):
            return bool(int(self.description['ErrorBands']))
        else:
            return False

    def getErrorBandColor(self):
        if self.description.has_key('ErrorBandColor'):
            return self.description['ErrorBandColor']
        else:
            return 'yellow'

    def startclip(self):
        return '\\psclip{\\psframe[linewidth=0, linestyle=none](0,0)(1,1)}\n'

    def stopclip(self):
        return '\\endpsclip\n'

    def startpsset(self):
        out = ""
        out += ('\\psset{linecolor='+self.getLineColor()+'}\n')
        out += ('\\psset{linewidth='+self.getLineWidth()+'}\n')
        out += ('\\psset{linestyle='+self.getLineStyle()+'}\n')
        out += ('\\psset{fillstyle='+self.getFillStyle()+'}\n')
        out += ('\\psset{fillcolor='+self.getFillColor()+'}\n')
        out += ('\\psset{hatchcolor='+self.getHatchColor()+'}\n')
        if self.getLineDash()!='':
            out += ('\\psset{dash='+self.getLineDash()+'}\n')
        return out

    def stoppsset(self):
        out = ""
        out += ('\\psset{linecolor=black}\n')
        out += ('\\psset{linewidth=0.8pt}\n')
        out += ('\\psset{linestyle=solid}\n')
        out += ('\\psset{fillstyle=none}\n')
        out += ('\\psset{fillcolor=white}\n')
        out += ('\\psset{hatchcolor=black}\n')
        return out



class Function(DrawableObject):
    def __init__(self, f):
        self.read_input(f)

    def read_input(self, f):
        self.description = {}
        self.code='def plotfunction(x):\n'
        iscode=False
        for line in f:
            if (line.count('#',0,1)):
                if (line.count('END FUNCTION')):
                    break
            else:
                if iscode:
                    self.code+='    '+line
                elif (line.count('=')):
                    line = line.rstrip()
                    linearray = line.split('=', 1)
                    if linearray[0]=='Code':
                        iscode=True
                    else:
                        self.description[linearray[0]] = linearray[1]
        if not iscode:
            print '++++++++++ ERROR: No code in function'

    def draw(self):
        out = ""
        out += self.startclip()
        out += self.startpsset()
        if self.description.has_key('XMin') and self.description['XMin']!='':
            min=float(self.description['XMin'])
        else:
            min=xmin
        if self.description.has_key('XMax') and self.description['XMax']!='':
            max=float(self.description['XMax'])
        else:
            max=xmax
        dx=(max-min)/500.
        x=min-dx
        out += ('\\pscurve')
        while x<(max+2*dx):
            foo=compile(self.code, '<string>', 'exec')
            exec(foo)
            y=plotfunction(x)
            out += ('(%s,%s)\n' % (coors.strphys2frameX(x), coors.strphys2frameY(y)))
            x+=dx
        out += self.stoppsset()
        out += self.stopclip()
        return out



class Histogram(DrawableObject):
    def __init__(self, f):
        self.read_input(f)

    def read_input(self, f):
        self.description = {}
        self.data = []
        for line in f:
            if (line.count('#',0,1)):
                if (line.count('END HISTOGRAM')):
                    break
            else:
                line = line.rstrip()
                if (line.count('=')):
                    linearray = line.split('=', 1)
                    self.description[linearray[0]] = linearray[1]
                else:
                    linearray = line.split('\t')
                    if len(linearray)==4:
                        self.data.append({'LowEdge': float(linearray[0]),
                                          'UpEdge':  float(linearray[1]),
                                          'Content': float(linearray[2]),
                                          'Error':   [float(linearray[3]),float(linearray[3])]})
                    elif len(linearray)==5:
                        self.data.append({'LowEdge': float(linearray[0]),
                                          'UpEdge':  float(linearray[1]),
                                          'Content': float(linearray[2]),
                                          'Error':   [float(linearray[3]),float(linearray[4])]})
                    else:
                        global is2dim
                        is2dim=True
                        self.data.append({'LowEdge': [float(linearray[0]), float(linearray[2])],
                                          'UpEdge':  [float(linearray[1]), float(linearray[3])],
                                          'Content': float(linearray[4]),
                                          'Error':   float(linearray[5])})
        if (self.description.has_key('NormalizeToIntegral') and self.description['NormalizeToIntegral']=='1') or \
           (self.description.has_key('NormalizeToSum') and self.description['NormalizeToSum']=='1'):
            if (self.description.has_key('NormalizeToIntegral') and self.description['NormalizeToIntegral']=='1') and \
               (self.description.has_key('NormalizeToSum') and self.description['NormalizeToSum']=='1'):
                print 'Can\'t normalize to Integral and to Sum at the same time. Will normalize to the Sum.'
            foo = 0
            for i in range(len(self.data)):
                if self.description.has_key('NormalizeToSum') and self.description['NormalizeToSum']=='1':
                    foo += self.data[i]['Content']
                else:
                    foo += self.data[i]['Content']*(self.data[i]['UpEdge']-self.data[i]['LowEdge'])
            for i in range(len(self.data)):
                self.data[i]['Content']  /= foo
                self.data[i]['Error'][0] /= foo
                self.data[i]['Error'][1] /= foo
        if self.description.has_key('Scale') and self.description['Scale']!='':
            for i in range(len(self.data)):
                self.data[i]['Content']  *= float(self.description['Scale'])
                self.data[i]['Error'][0] *= float(self.description['Scale'])
                self.data[i]['Error'][1] *= float(self.description['Scale'])
        if self.description.has_key('Rebin') and self.description['Rebin']!='':
            rebin=int(self.description['Rebin'])
            newdata=[]
            if rebin>=2:
                for i in range(0,(len(self.data)/rebin)*rebin,rebin):
                    foo=0.
                    barl=0.
                    baru=0.
                    for j in range(rebin):
                        foo +=self.data[i+j]['Content']
                        barl+=self.data[i+j]['Error'][0]**2
                        baru+=self.data[i+j]['Error'][1]**2
                    newdata.append({'LowEdge': self.data[i]['LowEdge'],
                                    'UpEdge':  self.data[i+rebin-1]['UpEdge'],
                                    'Content': foo/float(rebin),
                                    'Error':   [sqrt(barl)/float(rebin),sqrt(baru)/float(rebin)]})
                self.data=newdata

    def add(self,name):
        if len(self.data)!=len(name.data):
            print '+++ Error in Histogram.add(): Binning of histograms differs'
        for i in range(len(self.data)):
            if self.data[i]['LowEdge']==name.data[i]['LowEdge'] and \
                    self.data[i]['UpEdge']==name.data[i]['UpEdge']:
                self.data[i]['Content'] += name.data[i]['Content']
                self.data[i]['Error'][0] = sqrt(self.data[i]['Error'][0]**2 + name.data[i]['Error'][0]**2)
                self.data[i]['Error'][1] = sqrt(self.data[i]['Error'][1]**2 + name.data[i]['Error'][1]**2)
            else:
                print '+++ Error in Histogram.add(): Binning of histograms differs'

    def divide(self,name):
        if len(self.data)!=len(name.data):
            print '+++ Error in Histogram.divide(): Binning of histograms differs'
        for i in range(len(self.data)):
            if self.data[i]['LowEdge']==name.data[i]['LowEdge'] and \
               self.data[i]['UpEdge']==name.data[i]['UpEdge']:
                # FIXME: Is this kind of error calculation correct?
                try:
                    self.data[i]['Error'][0] /= name.data[i]['Content']
                except ZeroDivisionError:
                    self.data[i]['Error'][0]=0.
                try:
                    self.data[i]['Error'][1] /= name.data[i]['Content']
                except ZeroDivisionError:
                    self.data[i]['Error'][1]=0.
                try:
                    self.data[i]['Content'] /= name.data[i]['Content']
                except ZeroDivisionError:
                    self.data[i]['Content']=1.
#                self.data[i]['Error'][0] = sqrt(self.data[i]['Error'][0]**2 + name.data[i]['Error'][0]**2)
#                self.data[i]['Error'][1] = sqrt(self.data[i]['Error'][1]**2 + name.data[i]['Error'][1]**2)
            else:
                print '+++ Error in Histogram.divide(): Binning of histograms differs'

    def draw(self):
        out = ""
        out += self.startclip()
        out += self.startpsset()
        #
        if is2dim:
            for i in range(len(self.data)):
                out += ('\\psframe')
                color=int(129*(self.data[i]['Content']-zmin)/(zmax-zmin))
                if self.data[i]['Content']>zmax:
                    color=129
                if self.data[i]['Content']<zmin:
                    color=0
                out += ('[linewidth=0pt, fillstyle=solid, fillcolor={gradientcolors!!['+str(color)+']}]')
                out += ('(' + coors.strphys2frameX(self.data[i]['LowEdge'][0]) + ', ' \
                            + coors.strphys2frameY(self.data[i]['LowEdge'][1]) + ')(' \
                            + coors.strphys2frameX(self.data[i]['UpEdge'][0])  + ', ' \
                            + coors.strphys2frameY(self.data[i]['UpEdge'][1])  + ')\n')
        else:
            if self.getErrorBars():
                for i in range(len(self.data)):
                    if self.data[i]['Content']==0. and self.data[i]['Error']==[0.,0.]: continue
                    out += ('\psline')
                    out += ('(' + coors.strphys2frameX(self.data[i]['LowEdge']) + ', ' \
                                + coors.strphys2frameY(self.data[i]['Content']) + ')(' \
                                + coors.strphys2frameX(self.data[i]['UpEdge'])  + ', ' \
                                + coors.strphys2frameY(self.data[i]['Content']) + ')\n')
                    out += ('\psline')
                    bincenter = coors.strphys2frameX(.5*(self.data[i]['LowEdge']+self.data[i]['UpEdge']))
                    out += ('(' + bincenter + ', ' \
                                + coors.strphys2frameY(self.data[i]['Content']-self.data[i]['Error'][0]) + ')(' \
                                + bincenter + ', ' \
                                + coors.strphys2frameY(self.data[i]['Content']+self.data[i]['Error'][1]) + ')\n')
            else:
                if self.getErrorBands():
                    for i in range(len(self.data)):
                        out += ('\\psframe[dimen=outer,linecolor=%s,fillstyle=solid,fillcolor=%s]' %(self.getErrorBandColor(),self.getErrorBandColor()))
                        out += ('(' + coors.strphys2frameX(self.data[i]['LowEdge']) + ', ' \
                                    + coors.strphys2frameY(self.data[i]['Content']-self.data[i]['Error'][0]) + ')(' \
                                    + coors.strphys2frameX(self.data[i]['UpEdge'])  + ', ' \
                                    + coors.strphys2frameY(self.data[i]['Content']+self.data[i]['Error'][1]) + ')\n')
                out += ('\psline(-0.1,-0.1)\n')
                for i in range(len(self.data)):
                    out += ('(' + coors.strphys2frameX(self.data[i]['LowEdge']) + ', ' \
                                + coors.strphys2frameY(self.data[i]['Content']) + ')(' \
                                + coors.strphys2frameX(self.data[i]['UpEdge'])  + ', ' \
                                + coors.strphys2frameY(self.data[i]['Content']) + ')\n')
                out += ('(1.1,-0.1)')
        #
        if self.getPolyMarker() != '':
            for i in range(len(self.data)):
                if self.data[i]['Content']==0. and self.data[i]['Error']==[0.,0.]: continue
                out += ('\\psdot[dotstyle=%s,dotsize=%s,dotscale=%s](' %(self.getPolyMarker(),self.getDotSize(),self.getDotScale()) \
                            + coors.strphys2frameX(.5*(self.data[i]['LowEdge']+self.data[i]['UpEdge'])) + ', ' \
                            + coors.strphys2frameY(self.data[i]['Content']) + ')\n')
        out += self.stoppsset()
        out += self.stopclip()
        return out

    def getXMin(self):
        if is2dim:
            return self.data[0]['LowEdge'][0]
        else:
            return min([self.data[i]['LowEdge'] for i in range(len(self.data))])

    def getXMax(self):
        if is2dim:
            return self.data[-1]['UpEdge'][0]
        else:
            return max([self.data[i]['UpEdge'] for i in range(len(self.data))])

    def getYMin(self, xmin, xmax):
        if is2dim:
            return self.data[0]['LowEdge'][1]
        else:
            yvalues = []
            for i in range(len(self.data)):
                if ((self.data[i]['UpEdge'] > xmin or self.data[i]['LowEdge'] >= xmin) and \
                    (self.data[i]['LowEdge'] < xmax or self.data[i]['UpEdge'] <= xmax)):
                    foo = 0
                    if self.getErrorBars() or self.getErrorBands():
                        foo = self.data[i]['Content']-self.data[i]['Error'][0]
                    else:
                        foo = self.data[i]['Content']
                    if logy:
                        if foo>0: yvalues.append(foo)
                    else:
                        yvalues.append(foo)
            if len(yvalues) > 0:
                return min(yvalues)
            else:
                return self.data[0]['Content']

    def getYMax(self, xmin, xmax):
        if is2dim:
            return self.data[-1]['UpEdge'][1]
        else:
            yvalues = []
            for i in range(len(self.data)):
                if ((self.data[i]['UpEdge'] > xmin or self.data[i]['LowEdge'] >= xmin) and \
                    (self.data[i]['LowEdge'] < xmax or self.data[i]['UpEdge'] <= xmax)):
                    if self.getErrorBars() or self.getErrorBands():
                        yvalues.append(self.data[i]['Content']+self.data[i]['Error'][1])
                    else:
                        yvalues.append(self.data[i]['Content'])
            if len(yvalues) > 0:
                return max(yvalues)
            else:
                return self.data[0]['Content']

    def getZMin(self):
        if not is2dim:
            return 0
        zvalues = []
        for i in range(len(self.data)):
            if (self.data[i]['UpEdge'][0] > xmin and self.data[i]['LowEdge'][0] < xmax) and \
               (self.data[i]['UpEdge'][1] > ymin and self.data[i]['LowEdge'][1] < ymax):
                zvalues.append(self.data[i]['Content'])
        return min(zvalues)

    def getZMax(self):
        if not is2dim:
            return 0
        zvalues = []
        for i in range(len(self.data)):
            if (self.data[i]['UpEdge'][0] > xmin and self.data[i]['LowEdge'][0] < xmax) and \
               (self.data[i]['UpEdge'][1] > ymin and self.data[i]['LowEdge'][1] < ymax):
                zvalues.append(self.data[i]['Content'])
        return max(zvalues)



class Frame:
    def __init__(self):
        self.framelinewidth     = '0.3pt'

    def draw(self):
        out = ""
        out += ('\n%\n% Frame\n%\n')
        out += ('\\psframe[linewidth='+self.framelinewidth+',dimen=middle](0,0)(1,1)\n')
        return out



class Ticks:
    def __init__(self):
        self.majorticklinewidth = '0.3pt'
        self.minorticklinewidth = '0.3pt'
        self.majorticklength    = '9pt'
        self.minorticklength    = '4pt'

    def draw_ticks(self, min, max, plotlog=False, customticks=[], customminortickmarks=-1, custommajortickmarks=-1,drawlabels=True):
        out = ""
        if plotlog:
            x=int(log10(min))
            while (x<log10(max)+1):
                if 10**x>=min:
                    ticklabel=10**x
                    if ticklabel>min and ticklabel<max:
                        out += self.draw_majorticklabel(ticklabel)
                        out += self.draw_majortick(ticklabel)
                    if ticklabel==min or ticklabel==max:
                        out += self.draw_majorticklabel(ticklabel)
                    for i in range(2,10):
                        ticklabel=i*10**(x-1)
                        if ticklabel>min and ticklabel<max:
                            out += self.draw_minortick(ticklabel)
                x+=1
        elif customticks!=[]:
            for i in range(len(customticks)):
                value=customticks[i]['Value']
                label=customticks[i]['Label']
                if value>=min and value<=max:
                    out += self.draw_majortick(value)
                    out += self.draw_majorticklabel(value, label=label)
        else:
            xrange = max-min
            digits = int(log10(xrange))+1
            if (xrange < 1):
                digits -= 1
            foo = int(xrange/(10**(digits-1)))
            if (foo/9. > 0.5):
                tickmarks = 10
            elif (foo/9. > 0.2):
                tickmarks = 5
            elif (foo/9. > 0.1):
                tickmarks = 2

            if (custommajortickmarks>-1):
                if custommajortickmarks not in [1, 2, 5, 10, 20]:
                    print '+++ Error in Ticks.draw_ticks(): MajorTickMarks must be in [1, 2, 5, 10, 20]'
                else:
                    #if custommajortickmarks==1: custommajortickmarks=10
                    tickmarks = custommajortickmarks

            if (tickmarks == 2 or tickmarks == 20):
                minortickmarks = 3
            else:
                minortickmarks = 4
            if (customminortickmarks>-1):
                minortickmarks = customminortickmarks
            #
            x = 0
            while (x > min*10**digits):
                x -= tickmarks*100**(digits-1)
            while (x <= max*10**digits):
                if (x >= min*10**digits-tickmarks*100**(digits-1)):
                    ticklabel = 1.*x/10**digits
                    if (int(ticklabel) == ticklabel):
                        ticklabel = int(ticklabel)
                    if (float(ticklabel-min)/xrange >= -1e-5):
                        if (fabs(ticklabel-min)/xrange > 1e-5 and fabs(ticklabel-max)/xrange > 1e-5):
                            out += self.draw_majortick(ticklabel)
                        if drawlabels:
                            out += self.draw_majorticklabel(ticklabel)

                    xminor = x
                    for i in range(minortickmarks):
                        xminor += 1.*tickmarks*100**(digits-1)/(minortickmarks+1)
                        ticklabel = 1.*xminor/10**digits
                        if (ticklabel > min and ticklabel < max):
                            if (fabs(ticklabel-min)/xrange > 1e-5 and fabs(ticklabel-max)/xrange > 1e-5):
                                out += self.draw_minortick(ticklabel)
                x += tickmarks*100**(digits-1)
        return out

    def draw(self):
        pass

    def draw_minortick(self, ticklabel):
        pass

    def draw_majortick(self, ticklabel):
        pass

    def draw_majorticklabel(self, ticklabel):
        pass

    def get_ticklabel(self, value, plotlog=False):
        label=''
        if plotlog:
            bar = int(log10(value))
            if bar<0:
                sign='-'
            else:
                sign='\\,'
            if bar==0:
                label = '1'
            else:
                label = '10$^{'+sign+'\\text{'+str(abs(int(log10(value))))+'}}$'
        else:
            if fabs(value) < 1e-8: value=0
            label=str(value)
        return label



class XTicks(Ticks):
    def draw(self, customticks=[], custommajortickmarks=-1, customminortickmarks=-1,drawlabels=True):
        out = ""
        out += ('\n%\n% X-Ticks\n%\n')
        out += ('\\def\\majortickmarkx{\\psline[linewidth='+self.majorticklinewidth+'](0,0)(0,'+self.majorticklength+')}%\n')
        out += ('\\def\\minortickmarkx{\\psline[linewidth='+self.minorticklinewidth+'](0,0)(0,'+self.minorticklength+')}%\n')
        out += self.draw_ticks(xmin, xmax,\
                                   plotlog=logx,\
                                   customticks=customticks,\
                                   custommajortickmarks=custommajortickmarks,\
                                   customminortickmarks=customminortickmarks,drawlabels=drawlabels)
        return out

    def draw_minortick(self, ticklabel):
        return ('\\rput('+coors.strphys2frameX(ticklabel)+', 0){\\minortickmarkx}\n')

    def draw_majortick(self, ticklabel):
        return ('\\rput('+coors.strphys2frameX(ticklabel)+', 0){\\majortickmarkx}\n')

    def draw_majorticklabel(self, value, label=''):
        if label=='':
            label=self.get_ticklabel(value,logx)
        return ('\\rput('+coors.strphys2frameX(value)+', 0){\\rput[B](0,-2.3\\labelsep){'+label+'}}\n')



class YTicks(Ticks):
    def draw(self, customticks=[], custommajortickmarks=-1, customminortickmarks=-1):
        out = ""
        out += ('\n%\n% Y-Ticks\n%\n')
        out += ('\\def\\majortickmarky{\\psline[linewidth='+self.majorticklinewidth+'](0,0)('+self.majorticklength+',0)}%\n')
        out += ('\\def\\minortickmarky{\\psline[linewidth='+self.minorticklinewidth+'](0,0)('+self.minorticklength+',0)}%\n')
        out += self.draw_ticks(ymin, ymax,\
                                   plotlog=logy,\
                                   customticks=customticks,\
                                   custommajortickmarks=custommajortickmarks,\
                                   customminortickmarks=customminortickmarks)
        return out

    def draw_minortick(self, ticklabel):
        return ('\\rput(0, '+coors.strphys2frameY(ticklabel)+'){\\minortickmarky}\n')

    def draw_majortick(self, ticklabel):
        return ('\\rput(0, '+coors.strphys2frameY(ticklabel)+'){\\majortickmarky}\n')

    def draw_majorticklabel(self, value, label=''):
        if label=='':
            label=self.get_ticklabel(value,logy)
        return ('\\uput[180]{0}(0, '+coors.strphys2frameY(value)+'){'+label+'}\n')



class Coordinates:
    def __init__(self):
        pass

    def phys2frameX(self, x):
        if logx:
            if x>0:
                result = 1.*(log10(x)-log10(xmin))/(log10(xmax)-log10(xmin))
            else:
                return -10
        else:
            result = 1.*(x-xmin)/(xmax-xmin)
        if (fabs(result) < 1e-4):
            return 0
        else:
            return min(max(result,-10),10)

    def phys2frameY(self, y):
        if logy:
            if y>0:
                result = 1.*(log10(y)-log10(ymin))/(log10(ymax)-log10(ymin))
            else:
                return -10
        else:
            result = 1.*(y-ymin)/(ymax-ymin)
        if (fabs(result) < 1e-4):
            return 0
        else:
            return min(max(result,-10),10)

    def strphys2frameX(self, x):
        return str(self.phys2frameX(x))

    def strphys2frameY(self, y):
        return str(self.phys2frameY(y))


####################


import shutil
def process_datfile(datfile):
    global opts

    filename = datfile.replace('.dat','')
    if not os.access(datfile, os.R_OK):
        raise Exception("Could not read data file '%s'" % datfile)

    ## Create a temporary directory
    cwd = os.getcwd()
    datpath = os.path.join(cwd, datfile)
    tempdir = tempfile.mkdtemp('.make_plot')
    tempdatpath = os.path.join(tempdir, datfile)
    shutil.copy(datpath, tempdir)

    ## Make TeX file
    inputdata = Inputdata(filename)
    texpath = os.path.join(tempdir, '%s.tex' % filename)
    texfile = open(texpath, 'w')
    mp = MainPlot(inputdata).draw(inputdata)
    texfile.write(mp)
    rp = RatioPlot(inputdata).draw(inputdata)
    texfile.write(rp)
    texfile.close()

    if opts.OUTPUT_FORMAT != "TEX":
        ## Run LaTeX (in no-stop mode)
        logging.debug(os.listdir(tempdir))
        chdir = 'cd %s && ' % tempdir
        lcmd = 'latex "\scrollmode\input" %s' % texpath
        if not logging.getLogger().isEnabledFor(logging.DEBUG):
            lcmd += " > /dev/null"
        cmd = "(" + chdir + lcmd + ")"
        logging.debug(cmd)
        os.system(cmd)
        logging.debug(os.listdir(tempdir))

        ## Run dvips
        dvipsargs = ""
        if not logging.getLogger().isEnabledFor(logging.DEBUG):
            dvipsargs += "-q"
        ## Handle Minion Font
        if opts.OUTPUT_FONT == "MINION":
            dvipsargs += ' -Pminion'
        ## Choose format
        if opts.OUTPUT_FORMAT == "PDF":
            dvipsargs += ' -f | ps2pdf - > %s.pdf' % filename
        elif opts.OUTPUT_FORMAT == "EPS":
            dvipsargs += ' -f | ps2eps > %s.eps 2> /dev/null' % filename
        elif opts.OUTPUT_FORMAT == "PNG":
            dvipsargs += ' -f | convert -density 250 -flatten - %s.png' % filename
        else:
            dvipsargs += ' -o %s.ps' % filename
        dvcmd = 'dvips %s %s' % (filename, dvipsargs)
        cmd = "(" + chdir + dvcmd + ")"
        logging.debug(cmd)
        os.system(cmd)
        logging.debug(os.listdir(tempdir))

    ## Copy results back to main dir
    outbasename = filename
    outname = outbasename + "." + opts.OUTPUT_FORMAT.lower()
    outpath = os.path.join(tempdir, outname)
    if os.path.exists(outpath):
        shutil.copy(outpath, cwd)
    else:
        logging.error("No output file '%s' from processing %s" % (outname, datfile))

    ## Clean up
    if opts.NO_CLEANUP:
        logging.info('Keeping temp-files in %s' % tempdir)
    else:
        shutil.rmtree(tempdir, ignore_errors=True)


# ## Set up signal handling
# import signal
# RECVD_KILL_SIGNAL = None
# def handleKillSignal(signum, frame):
#     "Declare us as having been signalled, and return to default handling behaviour"
#     logging.critical("Signal handler called with signal " + str(signum))
#     RECVD_KILL_SIGNAL = signum
#     signal.signal(signum, signal.SIG_DFL)
# ## Signals to handle
# signal.signal(signal.SIGTERM, handleKillSignal);
# signal.signal(signal.SIGHUP,  handleKillSignal);


## Wrapper for a process thread which attempts to process datfiles until empty
import threading, Queue
class MkPlotThread( threading.Thread ):
    def run(self):
        global opts
        global datfiles
        while True:
            #if RECVD_KILL_SIGNAL is not None:
            #    exit(1)
            try:
                datfile = datfiles.get_nowait()
                logging.info("Plotting %s" % datfile)
                process_datfile(datfile)
            except Queue.Empty, e:
                #print "%s ending." % self.getName()
                break
            except Exception, e:
                print "Error: %s" % str(e)
                #exit(1)

####################


if __name__ == '__main__':
    msg = """\
Usage: %prog [options] file.dat [file2.dat ...]

TODO
 * use std method (from compphys marking) to kill the subprocess
 * Tidy LaTeX-writing code
 * Handle boolean values flexibly (yes, no, true, false, etc. as well as 1, 0)
"""

    ## Try to use Psyco optimiser
    try:
        import psyco
        psyco.full()
    except ImportError:
        pass


    ## Find number of (virtual) processing units
    numcores = os.sysconf('SC_NPROCESSORS_ONLN')
    if numcores is None:
        numcores = 1

    ## Work-around for global variable locking bug.
    ## We set the numcores default to 1 until we get
    ## rid of the global variables.
    numcores = 1

    ## Parse command line options
    from optparse import OptionParser, OptionGroup
    parser = OptionParser(usage=msg)
    parser.add_option("-n", "--num-threads", dest="NUM_THREADS", type=int,
                      default=numcores, help="max number of threads to be used [%s]" % numcores)
    parser.add_option("--palatino", dest="OUTPUT_FONT", action="store_const", const="PALATINO", default="PALATINO",
                      help="Use Palatino as font (default).")
    parser.add_option("--cm", dest="OUTPUT_FONT", action="store_const", const="CM", default="PALATINO",
                      help="Use Computer Modern as font.")
    parser.add_option("--minion", dest="OUTPUT_FONT", action="store_const", const="MINION", default="PALATINO",
                      help="Use Adobe Minion Pro as font. Note: You need to set TEXMFHOME first.")
    parser.add_option("--ps", dest="OUTPUT_FORMAT", action="store_const", const="PS", default="PS", 
                      help="Create PostScript output (default).")
    parser.add_option("--pdf", dest="OUTPUT_FORMAT", action="store_const", const="PDF", default="PS", 
                      help="Create PDF output.")
    parser.add_option("--eps", dest="OUTPUT_FORMAT", action="store_const", const="EPS", default="PS", 
                      help="Create Encapsulated PostScript output.")
    parser.add_option("--png", dest="OUTPUT_FORMAT", action="store_const", const="PNG", default="PS", 
                     help="Create PNG output.")
    parser.add_option("--tex", dest="OUTPUT_FORMAT", action="store_const", const="TEX", default="PS", 
                      help="Create TeX/LaTeX output.")
    parser.add_option("--no-cleanup", dest="NO_CLEANUP", action="store_true", default=False, 
                      help="Keep temporary directory and print its filename.")
    parser.add_option("--full-range", dest="FULL_RANGE", action="store_true", default=False, 
                      help="Plot full y range in LogY plots.")
    verbgroup = OptionGroup(parser, "Verbosity control")
    verbgroup.add_option("-V", "--verbose", action="store_const", const=logging.DEBUG, dest="LOGLEVEL",
                         default=logging.INFO, help="print debug (very verbose) messages")
    verbgroup.add_option("-Q", "--quiet", action="store_const", const=logging.WARNING, dest="LOGLEVEL",
                         default=logging.INFO, help="be very quiet")
    parser.add_option_group(verbgroup)
    opts, args = parser.parse_args()
    logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")


    ## Check for no args
    if len(args) == 0:
        logging.error(parser.get_usage())
        exit(2)

#     ## Test for latex and dvips
#     latex/dvips
#     ## Test for ps2pdf
#     if opts.OUTPUT_FORMAT == "PDF":
#         ps2pdf
#     ## Test for ps2eps        
#     if opts.OUTPUT_FORMAT == "EPS":
#         ps2eps

    ## Check minion font
    if opts.OUTPUT_FONT == "MINION":
        if os.system('kpsewhich minion.sty > /dev/null') != 0:
            logging.warning('Warning: Using "--minion" requires minion.sty to be installed. Ignoring it.')
            opts.OUTPUT_FONT = "PALATINO"

    ## Check for Palatino old style figures and small caps
    if (opts.OUTPUT_FONT == "PALATINO") and not(os.system('kpsewhich ot1pplx.fd > /dev/null')):
        opts.OUTPUT_FONT = "PALATINO_OSF"

    ## Fill queue
    datfiles = Queue.Queue(maxsize=-1)
    for d in args:
        datfiles.put(d)
    
    ## Run threads
    for threadnum in range(opts.NUM_THREADS):
        procthread = MkPlotThread()
        procthread.start()

