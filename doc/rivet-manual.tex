\documentclass{JHEP3}
%\JHEP{00(2007)000}

\include{preamble}

\title{Rivet user manual\\ {\smaller \textsc{version \RivetVersion}}}

\author{Andy Buckley\\ IPPP, Durham University, UK.\\ E-mail: \email{andy.buckley@durham.ac.uk}}
\author{Jonathan Butterworth\\ HEP Group, Dept. of Physics and Astronomy, UCL, London, UK.\\ E-mail: \email{J.Butterworth@ucl.ac.uk}}
\author{Leif L\"onnblad\\ Theoretical Physics, Lund University, Sweden.\\ E-mail: \email{lonnblad@thep.lu.se}}
\author{Hendrik Hoeth\\ Theoretical Physics, Lund University, Sweden.\\ E-mail: \email{hendrik.hoeth@cern.ch}}
\author{James Monk\\ HEP Group, Dept. of Physics and Astronomy, UCL, London, UK.\\ E-mail: \email{jmonk@hep.ucl.ac.uk}}
\author{Frank Siegert\\ IPPP, Durham University, UK.\\ E-mail: \email{frank.siegert@durham.ac.uk}}
\author{Lars Sonnenschein\\ CERN, Gen\`eve 1206, Switzerland.\\ E-mail: \email{sonne@cern.ch}}

\preprint{}
%\preprint{\hepth{9912999}}

\abstract{This is the manual and user guide for the Rivet system for the
  validation and tuning of Monte Carlo event generators. As well as the core
  Rivet library, this manual describes the usage of the \kbd{rivet} program and
  the AGILe generator interface library. The depth and level of description is
  chosen for users of the system, starting with the basics of using validation
  code written by others, and then covering sufficient details to write new
  Rivet analyses and calculational components.}

\keywords{Event generator, simulation, validation, tuning, QCD}


\begin{document} 


\section{Introduction}

This manual is a users' guide to using the Rivet generator validation
system. Rivet is a C++ class library, which provides the infrastructure and
calculational tools for simulation-level analyses, enabling physicists to
validate event generator models and tunings with minimal effort and maximum
portability. Rivet is designed to scale effectively to large numbers of analyses
for truly global validation, by transparent use of an automated result caching
system.

The Rivet ethos, if it may be expressed succinctly, is that user analysis code
should be extremely clean and easy to write --- ideally it should be
sufficiently self-explanatory to in itself be a reference to the experimental
analysis algorithm --- without sacrificing power or extensibility. The machinery
to make this possible is intentionally hidden from the view of all but the most
prying users. Generator independence is explicitly required by virtue of all
analyses operating on the generic ``HepMC'' event record.

The simplest way to use Rivet is via the \kbd{rivet} command line tool, which
analyses textual HepMC event records as they are generated and produces output
distributions in a structured textual format. The input events are generated
using the generator's own steering program, if one is provided; for generators
which provide no default way to produce HepMC output, the AGILe generator
interface library, and in particular the \kbd{agile-runmc} command which it
provides, may be useful. For those who wish to embed their analyses in some
larger framework, Rivet can also be run programmatically on HepMC event objects
with no special executable being required.

Before we get started, a declaration of intent: this manual is intended to be a
guide to using Rivet, rather than a comprehensive and painstakingly maintained
reference to the application programming interface (API) of the Rivet
library. For that purpose, you will hopefully find the online generated
documentation at \url{http://projects.hepforge.org/rivet} to be
sufficient. Similar API documentation is maintained for AGILe at
\url{http://projects.hepforge.org/agile}.


\subsection{Typographic conventions}
As is normal in computer user manuals, the typography in this manual is used to
indicate whether we are describing source code elements, commands to be run in a
terminal, the output of a command etc.

The main such clue will be the use of \kbd{typewriter-style} text: this
indicates the name of a command or code element --- class names, function names
etc. Typewriter font is also used for commands to be run in a terminal, but in
this case it will be prefixed by a dollar sign, as in \inp{echo ''Hello'' |
  cat}.  The output of such a command on the terminal will be typeset in
\outp{sans-serif} font. When we are documenting a code feature in detail (which
is not the main point of this manual), we will use square brackets to indicate
optional arguments, and italic font between angle brackets to represent an
argument name which should be replaced by a value,
e.g. \code{Event::applyProjection(\val{proj})}.

Following the example of Donald Knuth in his books on \TeX{}, in this document
we will indicate paragraphs of particular technicality or esoteric nature with a
``dangerous bend''\marginpar{\bendimg\\Dangerous bend} sign. These will
typically describe internals of Rivet of which most people will be fortunate
enough to remain happily ignorant without adverse effects. However they may be
of interest to detail obsessives, the inordinately curious and Rivet
hackers. You can certainly skip them on a first reading. Similarly, you may see
double bend signs \marginpar{\dblbendimg\\Double bend} --- the same rules apply
for these, but even more strongly.


\cleardoublepage
\part{Getting started with Rivet}
\label{part:gettingstarted}

As with many things, Rivet may be meaningfully approached at several distinct
levels of detail:

\begin{itemize}
\item The simplest, and we hope the most common, is to use the analyses which
  are already in the library to study events from a variety of generators and
  tunes: this is enormously valuable in itself and we encourage all manner of
  experimentalists and phenomenologists alike to use Rivet in this mode.
\item A more involved level of usage is to write your own Rivet analyses ---
  this may be done without affecting the installed standard analyses by use of a
  ``plugin'' system (although we encourage users who develop analyses to submit
  them to the Rivet developers for inclusion into a future release of the main
  package). This approach requires some understanding of programming within
  Rivet but you don't \emph{need} to know about exactly what the system is doing
  with the objects that you have defined.
\item Finally, Rivet developers and people who want to do non-standard things
  with their analyses will need to know something about the messy details of
  what Rivet's infrastructure is doing behind the scenes. But you'd probably
  rather be doing some physics!
\end{itemize}

The current part of this manual is for the first sort of user, who wants to get
on with studying some observables with a generator or tune, or comparing several
such models. Since everyone will fall into this category at some point, our
preent interest is to get you to that all-important ``physics plots'' stage as
quickly as possible. Analysis authors and Rivet service-mechanics will find the
more detailed information that they crave in Part~\ref{part:writinganalyses}.


\section{Quickstart}

The point of this section is to get you up and running with Rivet as soon as
possible. Doing this by hand may be rather frustrating, as Rivet depends on
several external libraries --- you'll get bored downloading and building them by
hand in the right order. Here we recommend two much simpler ways --- for the
full details of how to build Rivet by hand, please consult the Rivet Web page.


\paragraph{Ubuntu/Debian package archive}

A selection of HEP packages, including Rivet, are maintained as Debian/Ubuntu
Linux packages on the Launchpad PPA system:
\url{https://launchpad.net/~hep/+archive}. This is the nicest option for
Debian/Ubuntu, since not only will it work more easily than anything else, but
you will also automatically benefit from bug fixes and version upgrades as they
appear.

The PPA packages have been built as binaries for a variety of architectures, and
the package interdependencies are automatically known and used: all you need to
do on a Debian-type Linux system (Ubuntu included) is to add the Launchpad
archive address to your APT sources list and then request installation of the
\kbd{rivet} package in the usual way. See the Launchpad and system documentation
for all the details.


\paragraph{Bootstrap script}

For those not using Debian/Ubuntu systems, we have written a bootstrapping
script which will download tarballs of Rivet, AGILe and the other required
libraries, expand them and build them in the right order with the correct build
flags. This is generally nicer than doing it all by hand, and virtually
essential if you want to use the existing versions of FastJet, HepMC, generator
libraries, and so on from CERN AFS: there are issues with these versions which
the script works around, which you won't find easy to do yourself.

You can get the bootstrap script from the following Web address:
\url{http://svn.hepforge.org/rivet/bootstrap/rivet-bootstrap}

To run the script, we recommend that you choose a personal installation
directory. Personally, I make a \kbd{\home/local} directory for this purpose, to
avoid polluting my home directory with a lot of files. If you already use a
directory of the same name, you might want to use a separate one, say
\kbd{\home/rivetlocal}, such that if you need to delete everything in the
installation area you can do so without difficulties. You'll need to add
\kbd{\val{localdir}/bin} to your \var{PATH} environment variable and
\kbd{\val{localdir}/lib} to your \var{LD_LIBRARY_PATH}.

Now, change directory to your build area (you may also want to make this,
e.g. \kbd{\home/build}), and download the script:\\
\inp{wget \url{http://svn.hepforge.org/rivet/bootstrap/rivet-bootstrap}}\\
Now run it, specifying the install area as the argument:\\
\inp{chmod +x rivet-bootstrap}\\
\inp{./rivet-bootstrap \val{localdir}}

If you are running on a system where the CERN AFS area is mounted as
\path{/afs/cern.ch}, then the bootstrap script will attempt to use the pre-built
HepMC, LHAPDF, FastJet and GSL libraries from the LCG software area. Either way,
you'll see a large amount of build output, and finally a message telling you
what changes to your environment variables will make the system useable. 

You now have a working, installed copy of the Rivet and AGILe libraries, and the
\kbd{rivet} and \kbd{agile-runmc} executables: respectively these are the
command-line frontend to the Rivet analysis library, and a convenient steering
command for generators which do not provide their own main program with HepMC
output. To test that they work as expected, set the environment variables as
instructed, if you've not already done so, run this:\\
\inp{rivet --help}\\
%
This should print a quick-reference user guide for the \kbd{rivet} command to
the terminal. Similarly, for \kbd{agile-runmc},\\
\inp{agile-runmc --help}\\
\inp{agile-runmc --list-gens}\\
\inp{agile-runmc --beams=pp:14TeV FPythia:6413}\\
which should respectively print the help, list the available generators and make
10 LHC-type events using the Fortran Pythia 6.4.13 generator. You're on your
way! If no generators are listed, you probaby need to install a local
Genser-type generator repository: see \SectionRef{sec:genser}.

In this manual, because of its convenience, we will use \kbd{agile-runmc} as our
canonical way of producing a stream of HepMC event data; if your interest is in
running a generator like Sherpa or Herwig++ which provides its own native way to
make HepMC output, or a generator like Cascade or PHOJET which is not currently
supported by AGILe, then substitute the appropriate command in what follows.
We'll discuss using these commands in detail in \SectionRef{sec:rivetgun}.


\subsection{Getting generators for AGILe}
\label{sec:genser}

One last thing before continuing, though: the generators themselves. Again, if
you're running on a system with the CERN LCG AFS area mounted, then
\kbd{rivetgun} will attempt to automatically use the generators packaged by the
LCG Genser team.

Otherwise, you'll have to build your own mirror of the LCG generators. This
process is not standardised at the moment (this will hopefully
change), so we've provided a script, \kbd{agile-genser-bootstrap}:\\
\inp{wget \url{http://svn.hepforge.org/agile/genser/agile-genser-bootstrap}}

Now make yourself a Genser installation directory, e.g. \kbd{\var{HOME}/genser},
and \kbd{cd} into it. Then run the \kbd{agile-genser-bootstrap} script, and wait
for it all to build. Finally, set the \var{AGILE_GEN_PATH} path variable to
contain the \kbd{\val{genserDir}} directory: you should now have a few
generators to play with.

If you are interested in using a generator not currently supported by AGILe,
which does not output HepMC events in its native state, then please contact the
authors and hopefully we can help.


\subsection{Command completion}

A final installation point worth considering is using the supplied bash-shell
programmable completion setup for the \kbd{rivet} and \kbd{agile-runmc}
commands. Despite being cosmetic and semi-trivial, programmable completion makes
using \kbd{rivet} positively pleasant, especially since you no longer need to
remember the somewhat cryptic analysis names\footnote{Standard Rivet analyses
  have names which, as well as the publication date and experiment name,
  incorporate the 8-digit Spires ID code.}!

To use programmable completion, source the appropriate files from the install
location:\\
\inp{. \val{localdir}/share/Rivet/rivet-completion}\\
\inp{. \val{localdir}/share/AGILe/agile-completion}\\
If there is already a \kbd{\val{localdir}/etc/bash_completion.d} directory in
your install path, Rivet and AGILe's installation scripts will install extra
copies into that location, since automatically sourcing all completion files in
such a path is quite standard.

Apologies to \{C,k,z,\dots\}-shell users, but this feature is currently only
available for the \kbd{bash} shell. Anyone who feels like supplying fixes or
additions for their favourite shell is very welcome to get in touch with the
developers.



\section{Running Rivet analyses}
\label{sec:rivetgun}

The \kbd{rivet} executable is the easiest way to use Rivet, and will be our
example throughout this manual. This command reads HepMC events in the standard
ASCII format, either from file or from a text stream.

\subsection{The FIFO idiom}

Since you rarely want to store simulated HepMC events and they are
computationally cheap to produce (at least when compared to the remainder of
experiment simulation chains), we recommend using a Unix \emph{named pipe} (or
``FIFO'' --- first-in, first-out) to stream the events. While this may seem
unusual at first, it is just a nice way of ``pretending'' that we are writing to
and reading from a file, without actually involving any slow disk access or
building of huge files: a 1M event LHC run would occupy $\sim 60 GB$ on disk,
and typically it takes twice as long to make and analyse the events when the 
filesystem is involved! Here is an example:\\
\inp{mkfifo fifo.hepmc}\\
\inp{agile-runmc Pythia:6418 -o fifo.hepmc \&}\\
\inp{rivet -a EXAMPLE fifo.hepmc}\\
%
Note that the generator process (\kbd{agile-runmc} in this case) is
\emph{backgrounded} before \kbd{rivet} is run. This is absolutely necessary,
since the buffer size of a pipe in Linux is only 64K --- about the space
required to store one LHC event in HepMC's textual event format. The generator
process will have to wait until the buffer is cleared, e.g. by being read by
\kbd{rivet}, before computing or writing any more events. By running the
generator and \kbd{rivet} at the same time, this flow control through the buffer
is invisible to the user.
%http://home.gna.org/pysfst/tests/pipe-limit.html

In the following command examples, we will assume that a generator has been set
up to write to the \kbd{fifo.hepmc} FIFO, and just list the \kbd{rivet} command
that reads from that location. Some typical \kbd{agile-runmc} commands are
listed in \AppendixRef{app:agilerunmc}.


\subsection{Example \kbd{rivet} commands}

\begin{itemize}

\item \paragraph{Getting help:}{\kbd{rivet --help} will print a (hopefully)
    helpful list of options which may be used with the \kbd{rivet} command, as
    well as other information such as environment variables which may affect the
    run.}

\item \paragraph{Choosing analyses:}{\kbd{rivet --list-analyses} will list the
    available analyses, including both those in the Rivet distribution and any
    plugins which are found at runtime. \kbd{rivet --show-analysis \val{patt}}
    will show a lot of details about any analyses whose name match the
    \val{patt} regular expression pattern --- simple bits of analysis name are a
    perfectly valid subset of this. For example, \kbd{rivet --show-analysis
      CDF_200} exploits the standard Rivet analysis naming scheme to show
    details of all available CDF experiment analyses published in the
    ``noughties.''}

\item \paragraph{Running particular analyses:}{\kbd{rivet -a~DELPHI_1996_S3430090
      in.hepmc} will run the Rivet \kbd{DELPHI_1996_S3430090}\cite{Abreu:1996na}
    analysis on the events in the \kbd{in.hepmc} data file. This analysis is the
    one originally used for the \Delphi automated ``\textsc{Professor}''
    generator tuning.  If the first event in the data file does not have
    appropriate beams, the analysis will be disabled; since there is only one
    analysis in this case, the command will exit immediately with a warning.}

\item \paragraph{Using all analyses:}{\kbd{rivet -n~50000 -A -} will read up to 
    50k events from standard input (specified by the special ``-'' input filename) 
    and analyse them with \emph{all} the Rivet library analyses. As above, 
    incompatible analyses (based on beam particle IDs), will be removed before 
    the main analysis run begins.}

\item \paragraph{Histogramming:}{\kbd{rivet in.hepmc -H~foo} will read all the
    events in the \kbd{in.hepmc} file. The \kbd{-H} switch is used to specify
    that the output histogram file will be named \kbd{foo.aida}. By default the
    output file is called \kbd{Rivet.aida}.}

\item \paragraph{Fine-grained logging:}{\kbd{rivet in.hepmc -A
      -l~Rivet.Analysis=DEBUG~\cmdbreak -l~Rivet.Projection=DEBUG
      -l~Rivet.Projection.FinalState=TRACE~\cmdbreak -l~RivetGun=WARN
      -l~NEvt=WARN} analyse events as before, but will print different status
    information as the run progresses. Hierarchical logging control is possible
    down to the level of individual analyses and projections as shown above;
    this is useful for debugging without getting overloaded with debug
    information from \emph{all} the components at once. The default level is
    ``\textsc{info}'', which lies between ``\textsc{debug}'' and
    ``\textsc{warning}''; the ``\textsc{trace}'' level is for very low level
    information, and probably isn't needed by normal users.}

\end{itemize}



\section{Using analysis data}

In this section, we summarise how to use the data files which Rivet produces for
plotting, validation and tuning.

\subsection{Histogram formats}

Rivet currently produces output histogram data in the AIDA XML format. Most
people aren't familiar with AIDA (and we recommend that you remain that way!),
and it will disappear entirely from Rivet in version 1.2.0. You will probably
wish to cast the AIDA files to a different format for plotting, and for this we
supply several scripts.

\paragraph{Conversion to ROOT}

Your knee-jerk reaction is probably to want to know how to plot your Rivet
histograms in ROOT. Don't worry; you can recover from this unfortunate behaviour
after only a few months of therapy. For unrepentant ROOT junkies, Rivet installs
an \kbd{aida2root} script, which converts the AIDA records to a \kbd{.root} file
full of ROOT \kbd{TGraph}s. One word of warning: a bug in ROOT means that
\kbd{TGraph}s do not render properly from file because the axis is not drawn by
default. To display the plots correctly in ROOT you will need to pass the
\kbd{"AP"} drawing option string to either the \kbd{TGraph::Draw()} method, or
in the options box in the \kbd{TBrowser} GUI interface.

\paragraph{Conversion to ``flat format''}

Most of our histogramming is based around the YODA ``flat'' plain text format,
which can easily be read (and written) by hand. We provide a script called
\kbd{aida2flat} to do this conversion. Run \kbd{aida2flat -h} to get usage
instructions; in particular the Gnuplot and ``split output'' options are useful
for further visualisation. Aside from anything else, this is useful for simply
checking the contents of an AIDA file, with \kbd{aida2flat Rivet.aida | less}.

\vspace{1.8em}

\begin{detail}
  We get asked a lot about why we don't use ROOT internally: aside from a
  general unhappiness about the design and quality of the data objects in ROOT,
  the monolithic nature of the system makes it a big dependency for a system as
  small as Rivet. While not an issue for experimentalists, most theorists and
  generator developers do not use ROOT and we preferred to embed the AIDA
  system, which in its LWH implementation requires no external package. The
  replacement for AIDA will be another lightweight system rather than ROOT, with
  an emphasis on friendly, intuitive data object design, and correct handling of
  sample merging statistics for all data objects.
\end{detail}


\subsection{Plotting and comparing data}

Rivet comes with two commands --- \kbd{compare-histos} and \kbd{make-plots} ---
for comparing and plotting data files. These commands produce nice comparison
plots of publication quality from the YODA format text files, e.g.:\\
\inp{compare-plots path/to/CDF_2001_S4751469.aida py.aida:'Pythia 6.418' \cmdbreak hw.aida:'Herwig++ 2.3.0'}

This command will have compared the three named data files (ending in
\kbd{.aida}), identified which plots are available in them, and combined the MC
and reference plots appropriately into a set of plot data files ending with
\kbd{.dat}. The strings after the ":" for the MC files are specifying ID strings to
appear in the plot legends. You can also run compare-plots to just compare MC--MC
data files. More options are described by running \kbd{compare-histos --help}.

Incidentally, the reference files for each Rivet analysis are to be found in the
installed Rivet shared data directory, \kbd{\val{installdir}/share/Rivet}. You
can find the location of this by using the \kbd{rivet-config} command:\\
\inp{rivet-config --datadir}

\noindent
You can now plot the created data files using the make-plots command:\\
\inp{make-plots --pdf *.dat}\\
The \kbd{--pdf} flag makes the output plots in PDF format: by default the output
is in PostScript (\kbd{.ps}), and flags for conversion to EPS and PNG are also
available.



\cleardoublepage
\part{Standard Rivet analyses}
\label{part:analyses}

%\section{Rivet analyses reference guide}

In this section we describe the standard experimental analyses included with the
Rivet library. To maintain synchronisation with the code, these descriptions are
generated automatically from the metadata in the analysis objects
themselves. This is currently rather sparse, hence the briefness of the
descriptions shown here. Richer metadata will be added to the code soon!

\input{analyses}



\cleardoublepage
\part{How Rivet works}
\label{part:writinganalyses}
%\label{part:internals}

Hopefully by now you've run Rivet a few times and got the hang of the command
line interface and viewing the resulting analysis data files. Maybe you've got
some ideas of analyses that you would like to see in Rivet's library. If so,
then you'll need to know a little about Rivet's internal workings before you can
start coding: with any luck by the end of this section that won't seem
particularly intimidating.

The core objects in Rivet are ``projections'' and ``analyses''. Hopefully
``analyses'' isn't a surprise --- that's just the collection of routines that
will make histograms to compare with reference data, and the only things that
might differ there from experieces with HZTool are the new histogramming system
and the fact that we've used some object orientation concepts to make life a bit
easier. The meaning of ``projections'', as applied to event analysis, will
probably be less obvious. We'll discuss them now.


\section{Projections}

The name ``projection'' is meant to evoke thoughts of projection operators,
low-dimensional slices/views of high-dimensional spaces, and other things that
might appeal to physicists who view the world through quantum-tinted lenses. A
more mundane, but equally applicable, name would be ``observable calculators'',
but since that's a long name, the things they return aren't \emph{necessarily}
observable, and they all inherit from the \kbd{Projection} base class, we'll
stick to that name. It doesn't take long to get used to using the name as a
synonym for ``calculator'', without being intimidated by ideas that they might
be some sort of high-powered deep magic. 90\% of them is simple and
self-explanatory, as a peek under the bonnet of e.g. the all-important
\kbd{FinalState} projection will reveal.

Projections can be relatively simple things like event shapes (i.e. scalar,
vector or tensor quantities), or arbitrarily complex things like lossy or
selective views of the event final state. Most users will see them attached to
analyses by declarations in each analysis' constructor, but they can also be
recursively ``nested'' inside other projections\footnote{Provided there are no
  dependency loops in the projection chains! Strictly, only acyclic graphs of
  projection dependencies are valid, but there is currently no code in Rivet
  that will attempt to verify this restriction.} (provided there are no infinite
loops in the nesting chain.) Calling a complex projection in an analysis may
actually transparently execute many projections on each event.


\subsection{Projection caching}

Aside from semantic issues of how the class design assigns the process of
analysing events, projections are important computationally because they live in
a framework which automatically stores (``caches'') their results between
events. This is a crucial feature for the long-term scalability of Rivet, as the
previous experience with HZTool was that HERA validation code ran very slowly
due to repeated calculation of the same $k_\perp$ clustering algorithm (at that
time notorious for scaling as the 3rd power of the number of particles.)

A concrete example may help in understanding how this works. Let's say we have
two analyses which have the same run conditions, i.e. incoming beam types, beam
energies, etc. Each also uses the thrust event shape measure to define a set of
basis vectors for their analysis. For each event that gets passed to Rivet,
whichever analysis gets called first will immediately (although maybe
indirectly) call a \kbd{FinalState} projection to get a list of stable, physical
particles (filtering out the intermediate and book-keeping entries in the HepMC
event record). That FS projection is then ``attached'' to the event. Next, the
first analysis will call a \kbd{Thrust} projection which internally uses the
same final state projection to define the momentum vectors used in calculating
the thrust. Once finished, the thrust projection will also be attached to the
event.

So far, projections have offered no benefits. However, when the second analysis
runs it will similarly try to apply its final state and thrust projections to
the event. Rather than repeat the calculations, Rivet's infrastructure will
detect that an equivalent calculation has already been run and will just return
references to the already-run projections. Since projections can also contain
and use other projections, this model allows some substantial computational
savings, without the analysis author even needing to be particularly aware of
what is going on.

Observant readers may have noticed a problem with all this projection caching
cleverness: what if the final states aren't defined the same way? One might
provide charged final state particles only, or the acceptances (defined in
rapidity range and a IR \pT cutoff) might differ. Rivet handles this by
making each projection provide a comparison operator which is used to decide
whether the cached version is acceptable or if the calculation must be re-run
with different settings. Because projections can be nested, applying a top-level
projection to an event can spark off a cascade of comparisons, calculations and
cache accesses, making use of existing results wherever possible.


\subsection{Using projection caching}
So far this is all theory --- how does one actually use projections in Rivet?
First, you should understand that projections, while semantically stored within
each other, are actually all registered with a central \code{ProjectionHandler}
object.\footnote{As of version 1.1 onwards --- previously, they were stored as
  class members inside other \code{Projection}s and \code{Analysis} classes.}
The reason for this central registration is to ensure that all projections'
lifespans are managed in a consistent way, and to protect projection and
analysis authors from some technical subtleties in how C++ polymorphism works.

Inside the constructor of a \code{Projection} or \code{Analysis} class, you must
call the \code{addProjection} function. This takes two arguments, the projection
to be registered (by \code{const} reference), and a name. The name is local to
the parent object, so you need not worry about name clashes between objects. A
very important point is that the passed \code{Projection} is not the one that is
actually centrally registered --- that distinction belongs to a newly created
heap object which is created within the \code{addProjection} method by means of
the overloaded \code{Projection::clone()} method. Hence it is completely safe
--- and recommended --- to use only local (stack) objects in \code{Projection}
and \code{Analysis} constructors.


\begin{philosophy}
  At this point, if you have rightly bought into C++ ideas like super-strong
  type-safety, this proliferation of dynamic casting may worry you: the compiler
  can't possibly check if a projection of the requested name has been
  registered, nor whether the downcast to the requested concrete type is
  legal. These are very legitimate concerns!

  In truth, we'd \emph{like} to have this level of extra safety but in the past,
  when projections were held as members of \code{ProjectionApplier} classes
  rather than in the central \code{ProjectionHandler} repository, the benefits
  of the strong typing were outweighed by more serious and subtle bugs relating
  to projection lifetime and object ``slicing''. At least when the current
  approach goes wrong it will throw an unmissable \emph{runtime} error every
  time that you run it (until it's fixed, of course!) rather than silently do
  the wrong thing, as was the previous behaviour.

  Our problems here are a microcosm of the perpetual language battle between
  strict and dynamic typing, runtime versus compile time errors. In practice,
  this manifests itself as a trade-off between the benefits of static type
  safety and the inconvenience of the type-system gymnastics that it engenders.
  We take some comfort from the number of very good programs have been and are
  still written in dynamically typed, interpreted languages like Python, where
  virtually all error checking (barring first-scan parsing errors) must be done
  at runtime. By pushing \emph{some} checking to the domain of runtime errors,
  Rivet's code is (we believe) in practice safer, and certainly more clear and
  elegant. However, we believe that with runtime checking should come a culture
  of unit testing, which is not yet in place in Rivet.

  As a final thought, one reason for Rivet's internal complexity is that C++ is
  just not a very good language for this sort of thing: we are operating on the
  boundary between event generator codes, number crunching routines (including
  third party libraries like FastJet) and user routines. The former set
  unavoidably require native interfaces and benefit from static typing; the
  latter benefit from interface flexibility, fast prototyping and syntactic
  clarity. Maybe a future version of Rivet will break through the technical
  barriers to a hybrid approach and allow users to run compiled projections from
  interpreted analysis code. For now, however, we hope that our brand of
  ``slightly less safe C++'' will be a pleasant compromise.
\end{philosophy}


% \begin{detail}
% \TODO{How projection caching \emph{really} works}
% (skippable, but useful as a reference)
% \end{detail}

% \subsection{Standard projection summary}
% \TODO{foo}

% \subsection{Example projection}
% \TODO{bar}

% \subsection{Cuts and constraints}
% \TODO{baz}


\section{Analyses}

\subsection{Writing a new analysis}

This section provides a recipe that can be followed to write a new analysis
using the Rivet projections.

Every analysis must inherit from \code{Rivet::Analysis} and, in addition to the
constructor, must implement a minimum of three methods.  Those methods are
\code{init()}, \code{analyze(const Rivet::Event\&)} and \code{finalize()}, which
are called once at the beginning of the analysis, once per event and once at the
end of the analysis respectively.

The new analysis should include the header for the base analysis class plus
whichever Rivet projections are to be used and should work under the
\code{Rivet} namespace.  The header for a new analysis named \code{UserAnalysis}
that uses the \code{FinalState} projection might therefore start off looking
like this:
%
\begin{snippet}
#include "Rivet/Analysis.hh"

namespace Rivet {

  class UserAnalysis : public Analysis {
  public:
    UserAnalysis();
    void init();
    void analyze(const Event& event);
    void finalize();
  };

}
\end{snippet}

\subsubsection{Analysis constructor}
The constructor for the \code{UserAnalysis} class should add to the analysis all
of the projections that will be used.  Projections can be added to an analysis
with a call to \code{addProjection(Projection, std::string)}, which takes as
argument the projection to be added and a name by which that projection can
later be referenced.  For this example the \code{FinalState} projection is to be
referenced by the string \code{"FS"} to provide access to all of the final state
particles inside a detector pseudorapidity coverage of $\pm 5.0$.  The syntax to
create and add that projection inside the constructor for \code{UserAnalysis} is
as follows:
%
\begin{snippet}
Rivet::UserAnalysis() {
  const FinalState fs(-5.0, 5.0);
  addProjection(fs, "FS");
}
\end{snippet}

In addition to adding projections, the constructor may also impose certain
requirements upon the events that the analysis will work with.  A call to the
\code{setBeams} method declares that the analysis may only be run on events with
specific types of beam particles, for example adding the line
%
\begin{snippet}
  setBeams(PROTON, PROTON);
\end{snippet}
%
\noindent ensures that the analysis can only be run on events from proton-proton
collisions.  Other types of beam particles that may be used include
\code{ANTIPROTON}, \code{ELECTRON}, \code{POSITRON}, \code{MUON} and \code{ALL}.
The later of these declares that the analysis is suitable for use with any type
of collision and is the default.

Some analyses need to know the interaction cross section that was generated by
the Monte Carlo generator, typically in order to normalise histograms.
Depending on the Monte Carlo that is used and its interface to Rivet, the cross
section may or may not be known.  An analysis can therefore declare at the
beginning of a run that it will need the cross section information during the
finalisation stages.  Such a declaration can be used to prevent what would
otherwise be fruitless analyses from running.  An analysis sets itself as
requiring the cross section by calling inside the constructor
%
\begin{snippet}
  setNeedsCrossSection(true);
\end{snippet}
%
\noindent In the absence of this call the default is to assume that the analysis
does not need to know the cross section.

% It is often the case that an analysis is only appropriate for a limited range of
% Monte Carlo kinematic settings.  For example, an analysis may only be suitable
% if the minimum \pT in the hard scatter is above a certain value.  A mechanism
% exists with the \code{Analysis} object to declare the existence of such a cut.
% However, the relevant information must be made available by the Monte Carlo
% generator and, given the potentially large number of such generator-dependent
% cuts, this information is not currently checked by the AGILe generator
% interface.  Nevertheless, an analysis can add a cut in the constructor with a
% call to \code{addCut(const string\&, const Comparison\&, const double)}, which
% takes as its arguments the name of the cut, the comparison operator and a value
% to compare the cut quantity with.  For example, to add a cut stating that the
% hard scatter \pT must be above \unit{3}{\GeV} one should call

% \begin{snippet}
%   addCut("PT", MORE_EQ, 3.0*GeV);
% \end{snippet}



\subsection{Histogramming}
\TODO{Histo interfaces, AIDA and YODA. Formats.}

\subsection{Analysis histo autobinning}
\subsection{Pluggable analyses}
\subsection{Example analysis}

\section{Viewing output data files}

\section{Comparing with reference data}


\cleardoublepage
\part{Appendices}
\appendix


\section{Typical \kbd{agile-runmc} commands}
\label{app:agilerunmc}

\begin{itemize}
\item \paragraph{Simple run:}{\kbd{agile-runmc Herwig:6510 -P~lep1.params --beams=LEP:91.2
      -n~1000} will use the Fortran Herwig 6.5.10 generator (the \kbd{-g} option
    switch) to generate 1000 events (the \kbd{-n} switch) in LEP1 mode,
    i.e. $\Ppositron\Pelectron$ collisions at $\sqrt{s} = \unit{91.2}{\GeV}$.}
  
\item \paragraph{Parameter changes:}{\kbd{agile-runmc Pythia6:418
      --beams=LEP:91.2 -n~1000 \cmdbreak -P~myrun.params -p~"PARJ(82)=5.27"}
    will generate 1000 events using the Fortran Pythia 6.4.18 generator, again
    in LEP1 mode. The \kbd{-P} switch is actually the way of specifying a
    parameters file, with one parameter per line in the format ``\val{key}
    \val{value}'': in this case, the file \kbd{lep1.params} is loaded from the
    \kbd{\val{installdir}/share/AGILe} directory, if it isn't first found in the
    current directory.  The \kbd{-p} (lower-case) switch is used to change a
    named generator parameter, here Pythia's \kbd{PARJ(82)}, which sets the
    parton shower cutoff scale. Being able to change parameters on the command
    line is useful for scanning parameter ranges from a shell loop, or rapid
    testing of parameter values without needing to write a parameters file for
    use with~\kbd{-P}.}
  
\item \paragraph{Writing out HepMC events:}{\kbd{agile-runmc Pythia6:418
      --beams=LHC:14TeV -n~50 -o~out.hepmc -R} will generate 50 LHC events with
    Pythia. The~\kbd{-o} switch is being used here to tell \kbd{agile-runmc} to
    write the generated events to the \kbd{out.hepmc} file. This file will be a
    plain text dump of the HepMC event records in the standard HepMC format. Use
    of filename ``-'' will result in the event stream being written to standard
    output (i.e. dumping to the terminal.}
\end{itemize}


\cleardoublepage
\part{Bibliography}
\bibliographystyle{h-physrev3}
{\raggedright
  \bibliography{refs}
}


\end{document}
