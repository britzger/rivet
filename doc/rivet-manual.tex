\documentclass{JHEP3}
%\JHEP{00(2007)000}

\usepackage{xspace,graphicx,mparhack,amsmath}
\usepackage{amssymb,url,underscore,fancyvrb,cancel}
\usepackage{hepnicenames,hepunits}
\usepackage{picinpar,fancybox}
\usepackage{microtype,relsize}
\usepackage{rivetversion}
%\usepackage{xcolor}
%\usepackage{palatino,mathpazo}
%\usepackage{utopia}
%\usepackage{euler}


\DeclareRobustCommand{\TODO}[1]{\ensuremath{\bigstar}{#1}\xspace}
%\DeclareRobustCommand{\TODO}[1]{\textcolor{red!20!black}{\ensuremath{\bigstar}{#1}}\xspace}
%\DeclareRobustCommand{\TOCHECK}[1]{\textcolor{blue!20!black}{\ensuremath{\bigcircle}{#1}}\xspace}

%% Bold tt font
\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\newenvironment{snippet}{\Verbatim}{\endVerbatim}

\newcommand{\kbd}[1]{\texttt{#1}\xspace}
\newcommand{\inp}[1]{\textsf{\textdollar}\hspace{1mm}\texttt{#1}\xspace}
\newcommand{\outp}[1]{\textsf{#1}\xspace}
\newcommand{\code}[1]{\texttt{#1}\xspace}
\newcommand{\var}[1]{\texttt{\textdollar{}#1}\xspace}
\newcommand{\val}[1]{\textit{\ensuremath{\langle\text{\textrm{#1}\/}\rangle}}\xspace}
\newcommand{\home}{\texttt{\ensuremath{\sim}}\xspace}

%\newcommand{\RGnegate}{\texttt{\ensuremath{\sim}}}
\newcommand{\Delphi}{\textsc{Delphi}\xspace}

\newcommand{\cmdbreak}{\textbackslash\newline}

\newcommand{\AppendixRef}[1]{appendix~\ref{#1}}
\newcommand{\SectionRef}[1]{section~\ref{#1}}
\newcommand{\SubsectionRef}[1]{sub-section~\ref{#1}}

\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar{\footnotesize \textit{#1}}}
%\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize \textit{#1}]%
%{\raggedright\footnotesize \textit{#1}}}

\newcommand{\coneimg}{\includegraphics[height=11mm]{cone}}
\newcommand{\bendimg}{\includegraphics[height=11mm]{bend}}
\newcommand{\dblbendimg}{\bendimg\hspace{0.5mm}\bendimg}

\setlength{\fboxsep}{5mm}
\setlength{\linewidth}{5pt}

\newenvironment{change}%
{\begin{Sbox}%
      \begin{minipage}{0.9\textwidth}%
        \begin{window}[0,l,{\coneimg},{}] \noindent\hspace{-0.8ex}}%
        {\par\end{window}%
      \end{minipage}%
  \end{Sbox}%
  \vspace{5mm}%
  \noindent%
  \begin{center}%
    \fbox{\TheSbox}%
  \end{center}%
  \vspace{5mm}%
  \ignorespacesafterend}

% \newenvironment{change}{%
% \begin{window}[0,l,{\coneimg},{}] \noindent\hspace{-0.8ex}}{\par%
% % \showthe\prevgraf%
% % \showthe\prevdepth%
% % \ifnum\prevgraf<2\rule{1pt}{1.2cm}\fi%
% \end{window}\ignorespacesafterend}

%% Make narrower and box (box must be able to break over pages)
\newenvironment{philosophy}{\vspace{5mm}\hrule\nobreak\vspace{3mm}\begingroup%
  \it\begin{window}[0,l,{\bendimg},{}]
  \setlength{\parindent}{0cm}\noindent}{%
  \end{window}\endgroup\vspace{3mm}\nobreak\hrule\vspace{5mm}\ignorespacesafterend}
\newenvironment{detail}{\begin{window}[0,l,{\bendimg},{}]}{\end{window}\ignorespacesafterend}
\newenvironment{dbldetail}{\begin{window}[0,l,{\dblbendimg},{}]}{\end{window}\ignorespacesafterend}

\newcommand{\pT}{\ensuremath{p_\perp}\xspace}
\newcommand{\ET}{\ensuremath{E_\perp}\xspace}
\newcommand{\MET}{\ensuremath{\cancel{E_\perp}}\xspace}


\title{Rivet user manual\\ {\smaller \textsc{version \RivetVersion}}}

\author{Andy Buckley\\ IPPP, Durham University, UK.\\ E-mail: \email{andy.buckley@durham.ac.uk}}
\author{Jonathan Butterworth\\ HEP Group, Dept. of Physics and Astronomy, UCL, London, UK.\\ E-mail: \email{J.Butterworth@ucl.ac.uk}}
\author{Leif L\"onnblad\\ Theoretical Physics, Lund University, Sweden.\\ E-mail: \email{lonnblad@thep.lu.se}}
\author{Hendrik Hoeth\\ Theoretical Physics, Lund University, Sweden.\\ E-mail: \email{hoeth@thep.lu.se}}
\author{James Monk\\ HEP Group, Dept. of Physics and Astronomy, UCL, London, UK.\\ E-mail: \email{jmonk@hep.ucl.ac.uk}}
\author{Lars Sonnenschein\\ CERN, Gen\`eve 1206, Switzerland.\\ E-mail: \email{sonne@cern.ch}}

\preprint{}
%\preprint{\hepth{9912999}}

\abstract{This is the manual and user guide for the Rivet system for the
  validation and tuning of Monte Carlo event generators. As well as the core
  Rivet library, this manual describes the usage of the \kbd{rivet} program
  and the AGILe generator interface library. The level of description is
  generally intended for users of the system, starting with the basics of using
  validation code written by others, and then covering all the details you need
  to know to write your own Rivet components.}

\keywords{Event generator, simulation, validation, tuning, QCD}


\begin{document} 


\section{Introduction}
This manual is a users' guide to using the Rivet generator validation
system. Rivet itself is a C++ class library, with classes to represent
observable calculations, analyses and their data objects, and a collection of
infrastructure/management objects which you hopefully won't have to worry about
very much. The simplest way to use Rivet is via the \kbd{rivet} command line
tool, which analyses the HepMC event records as they are generated and produces
output distributions in a format of choice. The input events are generated using
the generator's own steering program, if one is provided; for generators which
provide no default way to produce HepMC output, the \kbd{agile-runmc} command
provided by the AGILe generator interface library may be useful. For those who
wish to embed their analyses in some larger framework, Rivet can also be run
programmatically on HepMC event objects with no special executable being
required.

Before we get started, a declaration of intent: this manual is intended to be a
guide to using Rivet, rather than a comprehensive and painstakingly maintained
reference to the application programming interface (API) of the Rivet
library. For that purpose, you will hopefully find the online generated
documentation at \url{http://projects.hepforge.org/rivet} to be
sufficient. Similar API documentation is maintained for AGILe at
\url{http://projects.hepforge.org/agile}.


\subsection{Typographic conventions}
As is normal in computer user manuals, the typography in this manual is used to
indicate whether we are describing source code elements, commands to be run in a
terminal, the output of a command etc.

The main such clue will be the use of \kbd{typewriter-style} text: this
indicates the name of a command or code element --- class names, function names
etc. Typewriter font is also used for commands to be run in a terminal, but in
this case it will be prefixed by a dollar sign, as in \inp{echo ''Hello'' |
  cat}.  The output of such a command on the terminal will be typeset in
\outp{sans-serif} font. When we are documenting a code feature in detail (which
is not the main point of this manual), we will use square brackets to indicate
optional arguments, and italic font between angle brackets to represent an
argument name which should be replaced by a value,
e.g. \code{Event::applyProjection(\val{proj})}.

Following the example of Donald Knuth in his books on \TeX{}, in this document
we will indicate paragraphs of particular technicality or esoteric nature with a
``dangerous bend''\marginpar{\bendimg\\Dangerous bend} sign. These will
typically be about the internals of Rivet which most people will be lucky enough
never to need know about, but for detail obsessives, the inordinately curious
and Rivet hackers they may be useful. You can almost certainly skip them on a
first reading. Similarly, you may see double bend signs
\marginpar{\dblbendimg\\Double bend} --- the same rules apply for these, but
even more strongly.


\clearpage
\part{Getting started with Rivet}
\label{part:gettingstarted}

As with many things, there are different levels at which one can use Rivet. The
simplest is just to use the analyses which are already in the library to check
the events made by a variety of generators and tunes: this is enormously
valuable in itself. A more involved level of usage is to write your own Rivet
analyses and either use them as plugins or send them to the authors to become
part of the base system: this requires some understanding of programming within
Rivet but you don't \emph{need} to know about exactly what the system is doing
with your code objects. Finally, Rivet developers and people who want to do
non-standard things with their analyses will need to know something about the
messy details of what Rivet's infrastructure is doing behind the scenes.

This part of the manual is for the first sort of user, who wants to get on with
making some plots with their new generator. Since everyone will fall into this
category at some point, our interest is to get you to that all-important physics
plots stage as quickly as possible. Analysis authors and Rivet service mechanics
will find more detailed information in part~\ref{part:writinganalyses}. % and \ref{}


\section{Quickstart}
The point of this section is to get you up and running with Rivet as soon as
possible. Doing this by hand may be rather frustrating, as Rivet depends on
several external libraries --- you'll get bored downloading and building them by
hand in the right order. Here we recommend two much simpler ways --- for the
full details of how to build Rivet by hand, please consult the Rivet Web page.


\paragraph{Ubuntu/Debian package archive}

A selection of HEP packages, including Rivet, are maintained as Debian/Ubuntu
Linux packages on the Launchpad PPA system:
\url{https://launchpad.net/~hep/+archive}. This is the nicest option for
Debian/Ubuntu, since not only will it work more easily than anything else, but
you will also automatically benefit from bug fixes and version upgrades as they
appear.

The PPA packages have been built as binaries for a variety of architectures, and
the package interdependencies are automatically known and used: all you need to
do on a Debian Linux system (Ubuntu included) is to add the Launchpad archive
address to your APT sources list and then request installation of the
\kbd{rivet} package in the usual way. See the Launchpad and system documentation
for all the details.


\paragraph{Bootstrap script}

For those not using Debian/Ubuntu systems, we have written a bootstrapping
script which will download tarballs of Rivet, AGILe and the other required
libraries, expand them and build them in the right order with the correct build
flags. This is generally nicer than doing it all by hand, and virtually
essential if you want to use the existing versions of FastJet, HepMC, generator
libraries, and so on from CERN AFS: there are issues with these versions which
the script works around, which you won't find easy to do yourself.

You can get the bootstrap script from the following Web address:
\url{http://svn.hepforge.org/rivet/bootstrap/rivet-bootstrap}

To run the script, we recommend that you choose a personal installation
directory. Personally, I make a \kbd{\home/local} directory for this purpose, to
avoid polluting my home directory with a lot of files. If you already use a
directory of the same name, you might want to use a separate one, say
\kbd{\home/rivetlocal}, such that if you need to delete everything in the
installation area you can do so without difficulties. You'll need to add
\kbd{\val{localdir}/bin} to your \var{PATH} environment variable and
\kbd{\val{localdir}/lib} to your \var{LD_LIBRARY_PATH}.

Now, change directory to your build area (you may also want to make this,
e.g. \kbd{\home/build}), and download the script:\\
\inp{wget \url{http://svn.hepforge.org/rivet/bootstrap/rivet-bootstrap}}\\
Now run it, specifying the install area as the argument:\\
\inp{chmod a+x rivet-bootstrap}\\
\inp{./rivet-bootstrap \val{localdir}}

If you are running on a system where the CERN AFS area is mounted as
\path{/afs/cern.ch}, then the bootstrap script will attempt to use the pre-built
HepMC, LHAPDF, FastJet and GSL libraries from the LCG software area. Either way,
you'll see a large amount of build output, and finally a message telling you
what changes to your environment variables will make the system useable. 

You now have a working, installed copy of the Rivet and AGILe libraries, and the
\kbd{rivet} and \kbd{agile-runmc} executables: respectively these are the
command-line frontend to the Rivet analysis library, and a convenient steering
command for generators which do not provide their own main program with HepMC
output. To test that they work as expected, set the environment variables as
instructed, if you've not already done so, run this:\\
\inp{rivet --help}\\
This should print a quick-reference user guide for the \kbd{rivet} command to
the terminal. Similarly, for \kbd{agile-runmc},\\
\inp{agile-runmc --help}\\
\inp{agile-runmc --list-gens}\\
\inp{agile-runmc --beams=pp:14TeV FPythia:6413}\\
which should respectively print the help, list the available generators and make
10 LHC-type events using the Fortran Pythia 6.4.13 generator. You're on your
way! If no generators are listed, you probaby need to install a local
Genser-type generator repository: see \SectionRef{sec:genser}.

In this manual, because of its convenience, we will use \kbd{agile-runmc} as our
canonical way of producing a stream of HepMC event data; if your interest is in
running a generator like Sherpa or Herwig++ which provides its own native way to
make HepMC output, or a generator like Cascade or PHOJET which is not currently
supported by AGILe, then substitute the appropriate command in what
follows. We'll discuss using these commands in detail
in \SectionRef{sec:rivetgun}.


\subsection{Getting generators for AGILe}
\label{sec:genser}

One last thing before continuing, though: the generators themselves. Again, if
you're running on a system with the CERN LCG AFS area mounted, then
\kbd{rivetgun} will attempt to automatically use the generators packaged by the
LCG Genser team.

Otherwise, you'll have to build your own mirror of the LCG generators. This
process is not standardised at the moment (this will hopefully
change), so we've provided a script, \kbd{agile-genser-bootstrap}:\\
\inp{wget \url{http://svn.hepforge.org/agile/genser/agile-genser-bootstrap}}

Now make yourself a Genser installation directory, e.g. \kbd{\var{HOME}/genser},
and \kbd{cd} into it. Then run the \kbd{agile-genser-bootstrap} script, and wait
for it all to build. Finally, set the \var{AGILE_GEN_PATH} path variable to
contain the \kbd{\val{genserDir}} directory: you should now have a few
generators to play with.


\subsection{Command completion}

A final installation point worth considering is using the supplied bash-shell
programmable completion setup for the \kbd{rivet} and \kbd{agile-runmc}
commands. Despite being cosmetic and semi-trivial, programmable completion makes
these commands much more pleasant to use, especially in the case of \kbd{rivet},
since you no longer need to remember the somewhat cryptic analysis names! To use
programmable completion, source the appropriate files from the install location:\\
\inp{. \val{localdir}/share/Rivet/rivet-completion}\\
\inp{. \val{localdir}/share/AGILe/agile-completion}\\
Apologies to C-shell users, but this feature is only available for bash
users. Anyone who feels like supplying fixes or additions for their favourite
shell is very welcome to get in touch with the developers.



\section{Running Rivet analyses}
\label{sec:rivetgun}

The \kbd{rivet} executable is the easiest way to use Rivet, and will be our
example throughout this manual. This command reads HepMC events in the standard
ASCII format, either from file or from a text stream.

\subsection{The FIFO idiom}

Since you rarely want to store simulated HepMC events and they are
computationally cheap to produce (at least when compared to experiment
simulation chains), we recommend using a Unix \emph{named pipe} (or ``FIFO'' ---
first-in, first-out) to stream the events. While this may seem unusual at first,
it is just a nice way of ``pretending'' that we are writing to and reading from
a file, without actually involving any slow disk access or building of huge
files: a 1M event LHC run would occupy $\sim 60 GB$ on disk, and typically it
takes twice as long to make
and analyse the events when the filesystem is involved! Here's the commands:\\
\inp{mkfifo fifo.hepmc}\\
\inp{agile-runmc Pythia:6418 -o fifo.hepmc \&}\\
\inp{rivet -a EXAMPLE fifo.hepmc}\\
Note that the generator process (\kbd{agile-runmc} in this case) is
\emph{backgrounded} before \kbd{rivet} is run. This is absolutely necessary,
because the buffer size of a pipe in Linux is only 64K: about one LHC event. The
generator process will have to wait until the buffer is cleared, e.g. by being
read by \kbd{rivet}, before computing or writing any more events.
%http://home.gna.org/pysfst/tests/pipe-limit.html


In the following command examples, we will assume that a generator has been set
up to write to the \kbd{fifo.hepmc} FIFO, and just list the \kbd{rivet} command
that reads from that location. Some typical \kbd{agile-runmc} commands are
listed in \AppendixRef{app:agilerunmc}.


\subsection{Example \kbd{rivet} commands}

\begin{itemize}

\item \paragraph{Choosing analyses:}{\kbd{rivet -a~DELPHI_1996_S3430090
      in.hepmc} will run the Rivet \kbd{DELPHI_1996_S3430090}\cite{Abreu:1996na}
    analysis on the events in the \kbd{in.hepmc} data file. This analysis is the
    one originally used for the \Delphi automated ``\textsc{Professor}''
    generator tuning.  If the first event in the data file does not have
    appropriate beams, the analysis will be disabled; since there is only one
    analysis in this case, the command will exit immediately with a warning.}

\item \paragraph{Using all analyses:}{\kbd{rivet -n~50000 -A -} will read up to 
    50k events from standard input (specified by the special ``-'' input filename) 
    and analyse them with \emph{all} the Rivet library analyses. As above, 
    incompatible analyses (based on beam particle IDs), will be removed before 
    the main analysis run begins.}

\item \paragraph{Histogramming:}{\kbd{rivet in.hepmc -H~foo} will read all the
    events in the \kbd{in.hepmc} file. The \kbd{-H} switch is used to specify
    that the output histogram file will be named \kbd{foo.aida}. By default the
    output file is called \kbd{Rivet.aida}.}

\item \paragraph{Log level:}{\kbd{rivet in.hepmc -A
      -l~Rivet.Analysis=DEBUG~\cmdbreak -l~Rivet.Projection=DEBUG
      -l~Rivet.Projection.FinalState=TRACE~\cmdbreak -l~RivetGun=WARN
      -l~NEvt=WARN} analyse events as before, but will print different status
    information as the run progresses. Hierarchical logging control is possible
    down to the level of individual analyses and projections as shown above;
    this is useful for debugging without getting overloaded with debug
    information from \emph{all} the components at once. The default level is
    ``\textsc{info}'', which lies between ``\textsc{debug}'' and
    ``\textsc{warning}''; the ``\textsc{trace}'' level is for very low level
    information, and probably isn't needed by normal users.}

\end{itemize}



\section{Using analysis data}

In this section, we summarise how to use the data files which Rivet produces for
plotting, validation and tuning.


\subsection{Histogram formats}

Rivet currently produces output histogram data in the AIDA XML format. Most
people aren't familiar with AIDA (and we recommend that you remain that way!),
and it will disappear entirely from Rivet in version 1.2.0. You will probably
wish to cast the AIDA files to a different format for plotting, and for this we
supply several scripts.

\paragraph{Conversion to ROOT}
Your knee-jerk reaction is probably to want to know how to plot your Rivet
histograms in ROOT. (Don't worry; you can recover from this unfortunate
behaviour after only a few months of therapy.) For such ROOT junkies, we install
an \kbd{aida2root} script, which converts the AIDA \kbd{DataPointSet} records to
ROOT \kbd{TGraphs}. One word of warning: a bug in ROOT means that \kbd{TGraph}s
do not render properly from file because the axis is not drawn by default. To
display the plots correctly in ROOT you will need to pass the \kbd{"AP"} drawing
option string to either the \kbd{TGraph::Draw()} method, or in the options box
in the \kbd{TBrowser} GUI interface.

\paragraph{Conversion to ``flat format''}
Most of our histogramming is based around the YODA ``flat'' plain text format,
which can easily be read (and written) by hand. We provide a script called
\kbd{aida2flat} to do this conversion. Run \kbd{aida2flat -h} to get usage
instructions; in particular the Gnuplot and ``split output'' options are useful
for further visualisation. Aside from anything else, this is useful for simply
checking the contents of an AIDA file, with \kbd{aida2flat Rivet.aida | less}.

We get asked a lot about why we don't use ROOT internally: aside from a general
unhappiness about the design and quality of the data objects in ROOT, the
monolithic nature of the system makes it a big dependency for a system as small
as Rivet. While not an issue for experimentalists, most theorists and generator
developers do not use ROOT and we preferred to embed the AIDA system, which in
its LWH implementation requires no external package. The replacement for AIDA
will be another lightweight system rather than ROOT, with an emphasis on
friendly, intuitive data object design, and correct handling of sample merging
statistics for all data objects.


\subsection{Plotting and comparing data}

Rivet comes with two commands --- \kbd{compare-histos} and \kbd{make-plots} ---
for comparing and plotting data files. These commands produce nice comparison
plots of publication quality from the YODA format text files, e.g.:\\
\inp{compare-plots path/to/CDF_2001_S4751469.aida py.aida:'Pythia 6.418' \cmdbreak hw.aida:'Herwig++ 2.3.0'}

This command will have compared the three named data files (ending in
\kbd{.aida}), identified which plots are available in them, and combined the MC
and reference plots appropriately into a set of plot data files ending with
\kbd{.dat}. The strings after the ":" for the MC files are specifying ID strings to
appear in the plot legends. You can also run compare-plots to just compare MC--MC
data files. More options are described by running \kbd{compare-histos --help}.

Incidentally, the reference files for each Rivet analysis are to be found in the
installed Rivet shared data directory, \kbd{\val{installdir}/share/Rivet}. You
can find the location of this by using the \kbd{rivet-config} command:\\
\inp{rivet-config --datadir}

\noindent
You can now plot the created data files using the make-plots command:\\
\inp{make-plots --pdf *.dat}\\
The \kbd{--pdf} flag makes the output plots in PDF format: by default the output
is in PostScript (\kbd{.ps}), and flags for conversion to EPS and PNG are also
available.


\clearpage
\part{Standard Rivet analyses}
\label{part:analyses}

In this section we describe the standard experimental analyses included with the
Rivet library. To maintain synchronisation with the code, these descriptions are
generated automatically from the metadata in the analysis objects
themselves. This is currently rather sparse, hence the briefness of the
descriptions shown here. Richer metadata will be added to the code soon!

\input{analyses}


\clearpage
\part{How Rivet works}
\label{part:writinganalyses}
%\label{part:internals}

Hopefully by now you've run Rivet a few times and got the hang of the command
line interface and viewing the resulting analysis data files. Maybe you've got
some ideas of analyses that you would like to see in Rivet's library. If so,
then you'll need to know a little about Rivet's internal workings before you can
start coding: with any luck by the end of this section that won't seem
particularly intimidating.

The core objects in Rivet are ``projections'' and ``analyses''. Hopefully
``analyses'' isn't a surprise --- that's just the collection of routines that
will make histograms to compare with reference data, and the only things that
might differ there from experieces with HzTool are the new histogramming system
and the fact that we've used some OO features to make life a bit easier. The
meaning of ``projections'', as applied to event analysis, will probably be less
obvious. We'll discuss them now.


\section{Projections}
The name ``projection'' is meant to evoke thoughts of
projection operators, low-dimensional slices/views of high-dimensional spaces,
and other things that might appeal to physicists who view the world through
quantum-tinted lenses. A more mundane, but equally applicable, name would be
``observables'', but since they all inherit from the \kbd{Projection} base
class, we'll stick to that name. Projections can be relatively simple things
like event shapes (i.e. scalar, vector or tensor quantities), or arbitrarily
complex things like lossy or selective views of the event final
state.\footnote{The ability for projections to return arbitrarily complex objects
  constructed from the event record is why we chose a slightly vague term like
  ``projection'' rather than ``observable'', which many people interpret as
  ``something I can plot.''}

\subsection{Projection caching}
Aside from semantic issues of how we're dividing the computational work of
analysing events, projections are important computationally because they live
within a framework which automatically stores (``caches'') their results between
events.

A concrete example may help here: let's say we have two analyses which
have the same run conditions, i.e. incoming beam types, beam energies, etc. Each
also uses the thrust event shape measure to define a set of basis vectors for
their analysis. For each event that gets passed to Rivet, whichever analysis
gets called first will first call a final state projection to get a list of
stable, physical particles (filtering out the intermediate and book-keeping
entries in the HepMC event record). That final state projection is then
``attached'' to the event. The analysis will then call a thrust projection which
has been told to use the same final state projection to define the momentum
vectors used in the thrust calculation, and similarly the thrust projection will
be registered with the event.

So far, projections have offered no benefits! However, when the second analysis
runs, it will similarly apply its final state and thrust projections to the
event, but the infrastructure will detect that an equivalent calculation has
already been done and will return references to the already-run
projections. Since projections can also contain and use other
projections\footnote{Although chains of projections had better not form a
  dependency loop! Strictly, what is allowed is an acyclic graph of projection
  chains, but there is currently no code in Rivet that will attempt to verify
  this restriction.} each other (``nesting''), this model allows some substantial
computational savings, without the analysis author even needing to be
particularly aware of what is going on.

Observant readers may have noticed a problem with all this projection caching
cleverness: what if the final states aren't defined the same way? One might
provide charged final state particles only, or the acceptances (defined in
rapidity range and a IR \pT cutoff) might differ. Rivet handles this by
making each projection provide a comparison operator which is used to decide
whether the cached version is acceptable or if the calculation must be re-run
with different settings. Because projections can be nested, applying a top-level
projection to an event can spark off a cascade of comparisons, calculations and
cache accesses, making use of existing results wherever possible.

\subsection{Using projection caching}
So far this is all theory --- how does one actually use projections in Rivet?
First, you should understand that projections, while semantically stored within
each other, are actually all registered with a central \code{ProjectionHandler}
object.\footnote{As of version 1.1 onwards --- previously, they were stored as
  class members inside other \code{Projection}s and \code{Analysis} classes.}
The reason for this central registration is to ensure that all projections'
lifespans are managed in a consistent way, and to protect projection and
analysis authors from some technical subtleties in how C++ polymorphism works.

Inside the constructor of a \code{Projection} or \code{Analysis} class, you must
call the \code{addProjection} function. This takes two arguments, the projection
to be registered (by \code{const} reference), and a name. The name is local to
the parent object, so you need not worry about name clashes between objects. A
very important point is that the passed \code{Projection} is not the one that is
actually centrally registered --- that distinction belongs to a newly created
heap object which is created within the \code{addProjection} method by means of
the overloaded \code{Projection::clone()} method. Hence it is completely safe
--- and recommended --- to use only local (stack) objects in \code{Projection}
and \code{Analysis} constructors.

\begin{philosophy}
  At this point, if you have rightly bought into C++ ideas like super-strong
  type-safety, this proliferation of dynamic casting may worry you: the compiler
  can't possibly check if a projection of the requested name has been
  registered, nor whether the downcast to the requested concrete type is
  legal. These are very legitimate concerns!

  In truth, we'd \emph{like} to have this level of extra safety but in the past,
  when projections were held as members of \code{ProjectionApplier} classes
  rather than in the central \code{ProjectionHandler} repository, the benefits
  of the strong typing were outweighed by more serious and subtle bugs relating
  to projection lifetime and object ``slicing''. At least when the current
  approach goes wrong it will throw an unmissable \emph{runtime} error every
  time that you run it (until it's fixed, of course!) rather than silently do
  the wrong thing, as was the previous behaviour.

  Our problems here are a microcosm of the perpetual language battle between
  strict and dynamic typing, runtime versus compile time errors. In practice,
  this manifests itself as a trade-off between the benefits of static type
  safety and the inconvenience of the type-system gymnastics that it engenders.
  We take some comfort from the number of very good programs have been and are
  still written in dynamically typed, interpreted languages like Python, where
  virtually all error checking (barring first-scan parsing errors) must be done
  at runtime. By pushing \emph{some} checking to the domain of runtime errors,
  Rivet's code is (we believe) in practice safer, and certainly more clear and
  elegant. However, we believe that with runtime checking should come a culture
  of unit testing, which is not yet in place in Rivet.

  As a final thought, one reason for Rivet's internal complexity is that C++ is
  just not a very good language for this sort of thing: we are operating on the
  boundary between event generator codes, number crunching routines (including
  third party libraries like FastJet) and user routines. The former set
  unavoidably require native interfaces and benefit from static typing; the
  latter benefit from interface flexibility, fast prototyping and syntactic
  clarity. Maybe a future version of Rivet will break through the technical
  barriers to a hybrid approach and allow users to run compiled projections from
  interpreted analysis code. For now, however, we hope that our brand of
  ``slightly less safe C++'' will be a pleasant compromise.
\end{philosophy}


% \begin{detail}
% \TODO{How projection caching \emph{really} works}
% (skippable, but useful as a reference)
% \end{detail}

% \subsection{Standard projection summary}
% \TODO{foo}

% \subsection{Example projection}
% \TODO{bar}

% \subsection{Cuts and constraints}
% \TODO{baz}


\section{Analyses}

\subsection{Writing a new analysis}

This section provides a recipe that can be followed to write a new analysis
using the Rivet projections.

Every analysis must inherit from \code{Rivet::Analysis} and, in addition to the
constructor, must implement a minimum of three methods.  Those methods are
\code{init()}, \code{analyze(const Rivet::Event\&)} and \code{finalize()}, which
are called once at the beginning of the analysis, once per event and once at the
end of the analysis respectively.

The new analysis should include the header for the base analysis class plus
whichever Rivet projections are to be used and should work under the
\code{Rivet} namespace.  The header for a new analysis named \code{UserAnalysis}
that uses the \code{FinalState} projection might therefore start off looking
like this:
%
\begin{snippet}
#include "Rivet/Analysis.hh"
#include "Rivet/Projections/FinalState.hh"

namespace Rivet {

  class UserAnalysis : public Analysis {
  public:
    UserAnalysis();
    void init();
    void analyze(const Event& event);
    void finalize();
  };

}
\end{snippet}

\subsubsection{Analysis constructor}
The constructor for the \code{UserAnalysis} class should add to the analysis all
of the projections that will be used.  Projections can be added to an analysis
with a call to \code{addProjection(Projection, std::string)}, which takes as
argument the projection to be added and a name by which that projection can
later be referenced.  For this example the \code{FinalState} projection is to be
referenced by the string \code{"FS"} to provide access to all of the final state
particles inside a detector pseudorapidity coverage of $\pm 5.0$.  The syntax to
create and add that projection inside the constructor for \code{UserAnalysis} is
as follows:
%
\begin{snippet}
Rivet::UserAnalysis() {
  const FinalState fs(-5.0, 5.0);
  addProjection(fs, "FS");
}
\end{snippet}

In addition to adding projections, the constructor may also impose certain
requirements upon the events that the analysis will work with.  A call to the
\code{setBeams} method declares that the analysis may only be run on events with
specific types of beam particles, for example adding the line
%
\begin{snippet}
  setBeams(PROTON, PROTON);
\end{snippet}
%
\noindent ensures that the analysis can only be run on events from proton-proton
collisions.  Other types of beam particles that may be used include
\code{ANTIPROTON}, \code{ELECTRON}, \code{POSITRON}, \code{MUON} and \code{ALL}.
The later of these declares that the analysis is suitable for use with any type
of collision and is the default.

Some analyses need to know the interaction cross section that was generated by
the Monte Carlo generator, typically in order to normalise histograms.
Depending on the Monte Carlo that is used and its interface to Rivet, the cross
section may or may not be known.  An analysis can therefore declare at the
beginning of a run that it will need the cross section information during the
finalisation stages.  Such a declaration can be used to prevent what would
otherwise be fruitless analyses from running.  An analysis sets itself as
requiring the cross section by calling inside the constructor
%
\begin{snippet}
  setNeedsCrossSection(true);
\end{snippet}
%
\noindent In the absence of this call the default is to assume that the analysis
does not need to know the cross section.

It is often the case that an analysis is only appropriate for a limited range of
Monte Carlo kinematic settings.  For example, an analysis may only be suitable
if the minimum \pT in the hard scatter is above a certain value.  A mechanism
exists with the \code{Analysis} object to declare the existence of such a cut.
However, the relevant information must be made available by the Monte Carlo
generator and, given the potentially large number of such generator-dependent
cuts, this information is not currently checked by the AGILe generator
interface.  Nevertheless, an analysis can add a cut in the constructor with a
call to \code{addCut(const string\&, const Comparison\&, const double)}, which
takes as its arguments the name of the cut, the comparison operator and a value
to compare the cut quantity with.  For example, to add a cut stating that the
hard scatter \pT must be above \unit{3}{\GeV} one should call

\begin{snippet}
  addCut("PT", MORE_EQ, 3.0*GeV);
\end{snippet}



\subsection{Histogramming}
\TODO{Histo interfaces, AIDA and YODA. Formats.}

\subsection{Analysis histo autobinning}
\subsection{Pluggable analyses}
\subsection{Example analysis}

\section{Viewing output data files}

\section{Comparing with reference data}


\appendix

\section{Typical \kbd{agile-runmc} commands}
\label{app:agilerunmc}

\begin{itemize}
\item \paragraph{Simple run:}{\kbd{agile-runmc Herwig:6510 -P~lep1.params --beams=LEP:91.2
      -n~1000} will use the Fortran Herwig 6.5.10 generator (the \kbd{-g} option
    switch) to generate 1000 events (the \kbd{-n} switch) in LEP1 mode,
    i.e. $\Ppositron\Pelectron$ collisions at $\sqrt{s} = \unit{91.2}{\GeV}$.}
  
\item \paragraph{Parameter changes:}{\kbd{agile-runmc Pythia6:418
      --beams=LEP:91.2 -n~1000 \cmdbreak -P~myrun.params -p~"PARJ(82)=5.27"}
    will generate 1000 events using the Fortran Pythia 6.4.18 generator, again
    in LEP1 mode. The \kbd{-P} switch is actually the way of specifying a
    parameters file, with one parameter per line in the format ``\val{key}
    \val{value}'': in this case, the file \kbd{lep1.params} is loaded from the
    \kbd{\val{installdir}/share/AGILe} directory, if it isn't first found in the
    current directory.  The \kbd{-p} (lower-case) switch is used to change a
    named generator parameter, here Pythia's \kbd{PARJ(82)}, which sets the
    parton shower cutoff scale. Being able to change parameters on the command
    line is useful for scanning parameter ranges from a shell loop, or rapid
    testing of parameter values without needing to write a parameters file for
    use with~\kbd{-P}.}
  
\item \paragraph{Writing out HepMC events:}{\kbd{agile-runmc Pythia6:418
      --beams=LHC:14TeV -n~50 -o~out.hepmc -R} will generate 50 LHC events with
    Pythia. The~\kbd{-o} switch is being used here to tell \kbd{agile-runmc} to
    write the generated events to the \kbd{out.hepmc} file. This file will be a
    plain text dump of the HepMC event records in the standard HepMC format. Use
    of filename ``-'' will result in the event stream being written to standard
    output (i.e. dumping to the terminal.}
\end{itemize}


\bibliographystyle{h-physrev3}
{\raggedright
  \bibliography{refs}
}


\end{document}
